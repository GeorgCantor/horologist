{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Horologist is a group of libraries that aim to supplement Wear OS developers with features that are commonly required by developers but not yet available. \ud83c\udfb5 Media \u00b6 Horologist provides the Media Toolkit: a set of libraries to build Media apps on Wear OS and a sample app that you can run to see the toolkit in action. The toolkit includes: horologist-media-ui : common media UI components and screens like PlayerScreen . horologist-media : domain model for Media related functionality. Provides an abstraction to the UI module ( horologist-media-ui ) that is agnostic to the Player implementation. horologist-media-data : implementation of the domain module ( horologist-media ) using Media3 . horologist-media3-backend : Player on top of Media3 including functionalities such as avoiding playing music on the watch speaker. horologist-media-sample : sample app to listen to downloaded music. Player Screen Browse Screen Entity Screen \ud83d\udcc5 Composables \u00b6 High quality prebuilt composables, such as Time and Date pickers. horologist-composables DatePicker TimePickerWith12HourClock TimePicker SegmentedProgressIndicator \ud83d\udcd0 Compose Layout \u00b6 Layout related functionality such as a Navigation Aware Scaffold. horologist-compose-layout fillMaxRectangle() fadeAway() \ud83d\udd0a Audio and UI \u00b6 Domain model for Audio related functionality. Volume Control, Output switching. Subscribing to a Flow of changes in audio or output. horologist-audio horologist-audio-ui VolumeScreen \u2630 Tiles \u00b6 Kotlin coroutines flavoured TileService. horologist-tiles Why the name? \u00b6 The name mirrors the Accompanist name, and is also Watch related. https://en.wiktionary.org/wiki/horologist horologist (Noun) Someone who makes or repairs timepieces, watches or clocks. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2022 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#media","text":"Horologist provides the Media Toolkit: a set of libraries to build Media apps on Wear OS and a sample app that you can run to see the toolkit in action. The toolkit includes: horologist-media-ui : common media UI components and screens like PlayerScreen . horologist-media : domain model for Media related functionality. Provides an abstraction to the UI module ( horologist-media-ui ) that is agnostic to the Player implementation. horologist-media-data : implementation of the domain module ( horologist-media ) using Media3 . horologist-media3-backend : Player on top of Media3 including functionalities such as avoiding playing music on the watch speaker. horologist-media-sample : sample app to listen to downloaded music. Player Screen Browse Screen Entity Screen","title":"\ud83c\udfb5 Media"},{"location":"#composables","text":"High quality prebuilt composables, such as Time and Date pickers. horologist-composables DatePicker TimePickerWith12HourClock TimePicker SegmentedProgressIndicator","title":"\ud83d\udcc5 Composables"},{"location":"#compose-layout","text":"Layout related functionality such as a Navigation Aware Scaffold. horologist-compose-layout fillMaxRectangle() fadeAway()","title":"\ud83d\udcd0 Compose Layout"},{"location":"#audio-and-ui","text":"Domain model for Audio related functionality. Volume Control, Output switching. Subscribing to a Flow of changes in audio or output. horologist-audio horologist-audio-ui VolumeScreen","title":"\ud83d\udd0a Audio and UI"},{"location":"#tiles","text":"Kotlin coroutines flavoured TileService. horologist-tiles","title":"\u2630 Tiles"},{"location":"#why-the-name","text":"The name mirrors the Accompanist name, and is also Watch related. https://en.wiktionary.org/wiki/horologist horologist (Noun) Someone who makes or repairs timepieces, watches or clocks.","title":"Why the name?"},{"location":"#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"#license","text":"Copyright 2022 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"audio-ui/","text":"Audio Settings UI library \u00b6 Volume Screen \u00b6 A volume screen, showing the current audio output (headphones, speakers) and allowing to change the button with a stepper or bezel. VolumeScreen ( focusRequester = focusRequester ) Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-audio-ui:<version>\" }","title":"Audio UI Guide"},{"location":"audio-ui/#audio-settings-ui-library","text":"","title":"Audio Settings UI library"},{"location":"audio-ui/#volume-screen","text":"A volume screen, showing the current audio output (headphones, speakers) and allowing to change the button with a stepper or bezel. VolumeScreen ( focusRequester = focusRequester )","title":"Volume Screen"},{"location":"audio-ui/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-audio-ui:<version>\" }","title":"Download"},{"location":"audio/","text":"Audio Settings Library \u00b6 Domain model for Volume and Audio Output. val audioRepository = SystemAudioRepository . fromContext ( application ) audioRepository . increaseVolume () val volumeState : StateFlow < VolumeState > = audioRepository . volumeState val audioOutput : StateFlow < AudioOutput > = audioRepository . audioOutput val output = audioOutput . value if ( output is AudioOutput . BluetoothHeadset ) { println ( output . name ) } Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-audio:<version>\" }","title":"Audio Guide"},{"location":"audio/#audio-settings-library","text":"Domain model for Volume and Audio Output. val audioRepository = SystemAudioRepository . fromContext ( application ) audioRepository . increaseVolume () val volumeState : StateFlow < VolumeState > = audioRepository . volumeState val audioOutput : StateFlow < AudioOutput > = audioRepository . audioOutput val output = audioOutput . value if ( output is AudioOutput . BluetoothHeadset ) { println ( output . name ) }","title":"Audio Settings Library"},{"location":"audio/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-audio:<version>\" }","title":"Download"},{"location":"composables/","text":"Composables library \u00b6 Date Picker \u00b6 Segmented Progress Indicator \u00b6 Time Pickers \u00b6 Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-composables:<version>\" }","title":"Guide"},{"location":"composables/#composables-library","text":"","title":"Composables library"},{"location":"composables/#date-picker","text":"","title":"Date Picker"},{"location":"composables/#segmented-progress-indicator","text":"","title":"Segmented Progress Indicator"},{"location":"composables/#time-pickers","text":"","title":"Time Pickers"},{"location":"composables/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-composables:<version>\" }","title":"Download"},{"location":"compose-layout/","text":"Compose Layout library \u00b6 Navigation Scaffold. \u00b6 Syncs the TimeText, PositionIndicator and Scaffold to the current navigation destination state. The TimeText will scroll out of the way of content automatically. WearNavScaffold ( startDestination = \"home\" , navController = navController ) { scalingLazyColumnComposable ( \"home\" , scrollStateBuilder = { ScalingLazyListState ( initialCenterItemIndex = 0 ) } ) { MenuScreen ( scrollState = it . scrollableState , focusRequester = it . viewModel . focusRequester ) } scalingLazyColumnComposable ( \"items\" , scrollStateBuilder = { ScalingLazyListState () } ) { ScalingLazyColumn ( modifier = Modifier . fillMaxSize () . scrollableColumn ( it . viewModel . focusRequester , it . scrollableState ), state = it . scrollableState ) { items ( 100 ) { Text ( \"i = $ it \" ) } } } scrollStateComposable ( \"settings\" , scrollStateBuilder = { ScrollState ( 0 ) } ) { Column ( modifier = Modifier . fillMaxSize () . verticalScroll ( state = it . scrollableState ) . scrollableColumn ( focusRequester = it . viewModel . focusRequester , scrollableState = it . scrollableState ), horizontalAlignment = Alignment . CenterHorizontally ) { ( 1. . 100 ). forEach { Text ( \"i = $ it \" ) } } } } Box Inset Layout. \u00b6 Use as a break glass for simple layout to fit within a safe square. Box ( modifier = Modifier . fillMaxRectangle () ) { // App Content here } Fade Away Modifier \u00b6 Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-compose-layout:<version>\" }","title":"Guide"},{"location":"compose-layout/#compose-layout-library","text":"","title":"Compose Layout library"},{"location":"compose-layout/#navigation-scaffold","text":"Syncs the TimeText, PositionIndicator and Scaffold to the current navigation destination state. The TimeText will scroll out of the way of content automatically. WearNavScaffold ( startDestination = \"home\" , navController = navController ) { scalingLazyColumnComposable ( \"home\" , scrollStateBuilder = { ScalingLazyListState ( initialCenterItemIndex = 0 ) } ) { MenuScreen ( scrollState = it . scrollableState , focusRequester = it . viewModel . focusRequester ) } scalingLazyColumnComposable ( \"items\" , scrollStateBuilder = { ScalingLazyListState () } ) { ScalingLazyColumn ( modifier = Modifier . fillMaxSize () . scrollableColumn ( it . viewModel . focusRequester , it . scrollableState ), state = it . scrollableState ) { items ( 100 ) { Text ( \"i = $ it \" ) } } } scrollStateComposable ( \"settings\" , scrollStateBuilder = { ScrollState ( 0 ) } ) { Column ( modifier = Modifier . fillMaxSize () . verticalScroll ( state = it . scrollableState ) . scrollableColumn ( focusRequester = it . viewModel . focusRequester , scrollableState = it . scrollableState ), horizontalAlignment = Alignment . CenterHorizontally ) { ( 1. . 100 ). forEach { Text ( \"i = $ it \" ) } } } }","title":"Navigation Scaffold."},{"location":"compose-layout/#box-inset-layout","text":"Use as a break glass for simple layout to fit within a safe square. Box ( modifier = Modifier . fillMaxRectangle () ) { // App Content here }","title":"Box Inset Layout."},{"location":"compose-layout/#fade-away-modifier","text":"","title":"Fade Away Modifier"},{"location":"compose-layout/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-compose-layout:<version>\" }","title":"Download"},{"location":"compose-tools/","text":"Compose Tools library \u00b6 Tile Previews. \u00b6 Android Studio Preview support for tiles, using the TilesRenderer inside and AndroidView. Uses either raw Tiles proto, or the TilesLayoutRenderer abstraction to define a predictable process for generating a Tile for a given state. @WearPreviewDevices @WearPreviewFontSizes @Composable fun SampleTilePreview () { val context = LocalContext . current val tileState = remember { SampleTileRenderer . TileState ( 0 ) } val resourceState = remember { val image = BitmapFactory . decodeResource ( context . resources , R . drawable . ic_uamp ). toImageResource () SampleTileRenderer . ResourceState ( image ) } val renderer = remember { SampleTileRenderer ( context ) } TileLayoutPreview ( tileState , resourceState , renderer ) } Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-compose-tools:<version>\" }","title":"Compose Tools library"},{"location":"compose-tools/#compose-tools-library","text":"","title":"Compose Tools library"},{"location":"compose-tools/#tile-previews","text":"Android Studio Preview support for tiles, using the TilesRenderer inside and AndroidView. Uses either raw Tiles proto, or the TilesLayoutRenderer abstraction to define a predictable process for generating a Tile for a given state. @WearPreviewDevices @WearPreviewFontSizes @Composable fun SampleTilePreview () { val context = LocalContext . current val tileState = remember { SampleTileRenderer . TileState ( 0 ) } val resourceState = remember { val image = BitmapFactory . decodeResource ( context . resources , R . drawable . ic_uamp ). toImageResource () SampleTileRenderer . ResourceState ( image ) } val renderer = remember { SampleTileRenderer ( context ) } TileLayoutPreview ( tileState , resourceState , renderer ) }","title":"Tile Previews."},{"location":"compose-tools/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-compose-tools:<version>\" }","title":"Download"},{"location":"contributing/","text":"How to Contribute \u00b6 We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. If you find a common problem that you think would help other Wear developers please consider submitting a PR. Please avoid significant work before raising an issue https://github.com/google/horologist/issues with the label \"Feature Request\" Development \u00b6 The project should work immediately from a fresh checkout in Android Studio or with Gradle. When submitting a PR, please check API compatibility and lint rules first. A good first step is $ ./gradlew spotlessApply spotlessCheck compileDebugSources compileReleaseSources metalavaGenerateSignatureDebug lintDebug Also make sure you have Git LFS installed. Contributor License Agreement \u00b6 Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again. Code reviews \u00b6 All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests. Project Direction and Ownership \u00b6 There are a couple of reasons we may not accept an otherwise valuable contribution. Where the internal framework feature team, thinks the contribution is against the long term direction of the library. Where long term ownership is unclear, such as a large contribution that likely involves ongoing maintenance.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. If you find a common problem that you think would help other Wear developers please consider submitting a PR. Please avoid significant work before raising an issue https://github.com/google/horologist/issues with the label \"Feature Request\"","title":"How to Contribute"},{"location":"contributing/#development","text":"The project should work immediately from a fresh checkout in Android Studio or with Gradle. When submitting a PR, please check API compatibility and lint rules first. A good first step is $ ./gradlew spotlessApply spotlessCheck compileDebugSources compileReleaseSources metalavaGenerateSignatureDebug lintDebug Also make sure you have Git LFS installed.","title":"Development"},{"location":"contributing/#contributor-license-agreement","text":"Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.","title":"Contributor License Agreement"},{"location":"contributing/#code-reviews","text":"All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Code reviews"},{"location":"contributing/#project-direction-and-ownership","text":"There are a couple of reasons we may not accept an otherwise valuable contribution. Where the internal framework feature team, thinks the contribution is against the long term direction of the library. Where long term ownership is unclear, such as a large contribution that likely involves ongoing maintenance.","title":"Project Direction and Ownership"},{"location":"datalayer/","text":"DataLayer library \u00b6 For more information, visit the documentation: https://google.github.io/horologist/datalayer DataStore documentation https://developer.android.com/topic/libraries/architecture/datastore Direct DataLayer sample code https://github.com/android/wear-os-samples TODO Use CapabilityClient instead of NodeClient Consider switching local/remote to owner/reader Support WearableListenerService to handle changes to data. Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-datalayer:<version>\" }","title":"Guide"},{"location":"datalayer/#datalayer-library","text":"For more information, visit the documentation: https://google.github.io/horologist/datalayer DataStore documentation https://developer.android.com/topic/libraries/architecture/datastore Direct DataLayer sample code https://github.com/android/wear-os-samples TODO Use CapabilityClient instead of NodeClient Consider switching local/remote to owner/reader Support WearableListenerService to handle changes to data.","title":"DataLayer library"},{"location":"datalayer/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-datalayer:<version>\" }","title":"Download"},{"location":"media-data/","text":"Media Data library \u00b6 This library contains the implementation of the repositories defined in the media domain library , using Media3 and an internal database as data sources. It also exposes its data sources classes so they can be used by your custom repositories. MediaDownloadService \u00b6 An implementation of Media3 \u2019s DownloadService that, in conjunction with auxiliary classes, will monitor the state and progress of media downloads, and update the information in the internal database. Usage \u00b6 Add your own implementation of the service, extending MediaDownloadService ; Add your service implementation to your app\u2019s AndroidManifest.xml : <service android:name= \"MediaDownloadServiceImpl\" android:exported= \"false\" > <intent-filter> <action android:name= \"com.google.android.exoplayer.downloadService.action.RESTART\" /> <category android:name= \"android.intent.category.DEFAULT\" /> </intent-filter> </service>","title":"Media Data lib"},{"location":"media-data/#media-data-library","text":"This library contains the implementation of the repositories defined in the media domain library , using Media3 and an internal database as data sources. It also exposes its data sources classes so they can be used by your custom repositories.","title":"Media Data library"},{"location":"media-data/#mediadownloadservice","text":"An implementation of Media3 \u2019s DownloadService that, in conjunction with auxiliary classes, will monitor the state and progress of media downloads, and update the information in the internal database.","title":"MediaDownloadService"},{"location":"media-data/#usage","text":"Add your own implementation of the service, extending MediaDownloadService ; Add your service implementation to your app\u2019s AndroidManifest.xml : <service android:name= \"MediaDownloadServiceImpl\" android:exported= \"false\" > <intent-filter> <action android:name= \"com.google.android.exoplayer.downloadService.action.RESTART\" /> <category android:name= \"android.intent.category.DEFAULT\" /> </intent-filter> </service>","title":"Usage"},{"location":"media-playerscreen/","text":"Stateful PlayerScreen guide \u00b6 This is a guide on how to use the stateful PlayerScreen with your own implementation of PlayerRepository . Basic usage \u00b6 1. Implement PlayerRepository \u00b6 class PlayerRepositoryImpl : PlayerRepository { // implement required properties and functions } In the sample implementation below, the repository listens to the events of Media3 's Player and update its property values accordingly (see onIsPlayingChanged ). Its operations are also called on the Player (see setPlaybackSpeed ). class PlayerRepositoryImpl ( private val player : Player ) : PlayerRepository { private val _currentState : MutableStateFlow < PlayerState > = MutableStateFlow ( PlayerState . Idle ) override val currentState : StateFlow < PlayerState > = _currentState private val listener = object : Player . Listener { override fun onIsPlayingChanged ( isPlaying : Boolean ) { _currentState . value = if ( isPlaying ) { PlayerState . Playing } else { PlayerState . Ready } } } init { player . add ( listener ) } fun setPlaybackSpeed ( speed : Float ) { player . setPlaybackSpeed ( speed ) } } 2. Extend PlayerViewModel \u00b6 Pass your implementation of PlayerRepository as constructor parameter. class MyCustomViewModel ( playerRepository : PlayerRepositoryImpl ): PlayerViewModel ( playerRepository ) { // add custom implementation } 3. Add PlayerScreen \u00b6 Pass your PlayerViewModel extension as value to the constructor parameter. PlayerScreen ( playerViewModel = myCustomViewModel ) Class diagram \u00b6 The following diagram shows the interactions between the classes.","title":"Stateful PlayerScreen Guide"},{"location":"media-playerscreen/#stateful-playerscreen-guide","text":"This is a guide on how to use the stateful PlayerScreen with your own implementation of PlayerRepository .","title":"Stateful PlayerScreen guide"},{"location":"media-playerscreen/#basic-usage","text":"","title":"Basic usage"},{"location":"media-playerscreen/#1-implement-playerrepository","text":"class PlayerRepositoryImpl : PlayerRepository { // implement required properties and functions } In the sample implementation below, the repository listens to the events of Media3 's Player and update its property values accordingly (see onIsPlayingChanged ). Its operations are also called on the Player (see setPlaybackSpeed ). class PlayerRepositoryImpl ( private val player : Player ) : PlayerRepository { private val _currentState : MutableStateFlow < PlayerState > = MutableStateFlow ( PlayerState . Idle ) override val currentState : StateFlow < PlayerState > = _currentState private val listener = object : Player . Listener { override fun onIsPlayingChanged ( isPlaying : Boolean ) { _currentState . value = if ( isPlaying ) { PlayerState . Playing } else { PlayerState . Ready } } } init { player . add ( listener ) } fun setPlaybackSpeed ( speed : Float ) { player . setPlaybackSpeed ( speed ) } }","title":"1. Implement PlayerRepository"},{"location":"media-playerscreen/#2-extend-playerviewmodel","text":"Pass your implementation of PlayerRepository as constructor parameter. class MyCustomViewModel ( playerRepository : PlayerRepositoryImpl ): PlayerViewModel ( playerRepository ) { // add custom implementation }","title":"2. Extend PlayerViewModel"},{"location":"media-playerscreen/#3-add-playerscreen","text":"Pass your PlayerViewModel extension as value to the constructor parameter. PlayerScreen ( playerViewModel = myCustomViewModel )","title":"3. Add PlayerScreen"},{"location":"media-playerscreen/#class-diagram","text":"The following diagram shows the interactions between the classes.","title":"Class diagram"},{"location":"media-sample/","text":"Media Sample app \u00b6 This is an example of a media app for Wear OS. It supports listening to downloaded music. It loads a music catalog from a remote server and allows the user to browse the albums and songs. Tapping on a song will play it through connected speakers or headphones. Under the hood it uses Media3 .","title":"Media Sample app"},{"location":"media-sample/#media-sample-app","text":"This is an example of a media app for Wear OS. It supports listening to downloaded music. It loads a music catalog from a remote server and allows the user to browse the albums and songs. Tapping on a song will play it through connected speakers or headphones. Under the hood it uses Media3 .","title":"Media Sample app"},{"location":"media-toolkit/","text":"Media Toolkit \u00b6 Overview \u00b6 Horologist provides what it is called the \"Media Toolkit\": a set of libraries to build media apps on Wear OS and a sample app that you can run to see the toolkit in action. The following modules in the Horologist project are part of the toolkit: media-ui : common media UI components and screens like PlayerScreen . media : domain model for media related functionality. Provides an abstraction to the UI module ( media-ui ) that is agnostic to the Player implementation. media-data : implementation of the domain module ( media ) using Media3. media3-backend : Player on top of Media3 including functionalities such as avoiding playing music on the watch speaker. media-sample : sample app to listen to downloaded music. Architecture overview \u00b6 The Media Toolkit libraries are separated by layers (UI, domain and data) following the recommended app architecture . The reason for including a domain layer is to provide flexibility to projects to use the UI library or the data library independently. For example, if your project already contains an implementation for the player and you are only interested in using the media screens provided by the toolkit, then only the UI library needs to be added as a dependency. Thus, no extra dependencies ( e.g. Media3 ) will be added to your project. On the other hand, if your project does not need any of the media screens or media UI components provided by the UI library , and you are only interested in the player implementation, then only the data library needs to be added as a dependency to your project. Getting started \u00b6 The usage of the toolkit will vary according to the requirements of your project. As per architecture overview , your project might not need to add all the libraries of the toolkit as dependency. If that\u2019s the case, refer to the documentation of each library required to your project for a guide on how to get started. For a walkthrough on how to build a very simple media application using some libraries of the toolkit, refer to this guide . For good reference on how to use all the libraries available in the toolkit, refer to the code of the media-sample app.","title":"Overview"},{"location":"media-toolkit/#media-toolkit","text":"","title":"Media Toolkit"},{"location":"media-toolkit/#overview","text":"Horologist provides what it is called the \"Media Toolkit\": a set of libraries to build media apps on Wear OS and a sample app that you can run to see the toolkit in action. The following modules in the Horologist project are part of the toolkit: media-ui : common media UI components and screens like PlayerScreen . media : domain model for media related functionality. Provides an abstraction to the UI module ( media-ui ) that is agnostic to the Player implementation. media-data : implementation of the domain module ( media ) using Media3. media3-backend : Player on top of Media3 including functionalities such as avoiding playing music on the watch speaker. media-sample : sample app to listen to downloaded music.","title":"Overview"},{"location":"media-toolkit/#architecture-overview","text":"The Media Toolkit libraries are separated by layers (UI, domain and data) following the recommended app architecture . The reason for including a domain layer is to provide flexibility to projects to use the UI library or the data library independently. For example, if your project already contains an implementation for the player and you are only interested in using the media screens provided by the toolkit, then only the UI library needs to be added as a dependency. Thus, no extra dependencies ( e.g. Media3 ) will be added to your project. On the other hand, if your project does not need any of the media screens or media UI components provided by the UI library , and you are only interested in the player implementation, then only the data library needs to be added as a dependency to your project.","title":"Architecture overview"},{"location":"media-toolkit/#getting-started","text":"The usage of the toolkit will vary according to the requirements of your project. As per architecture overview , your project might not need to add all the libraries of the toolkit as dependency. If that\u2019s the case, refer to the documentation of each library required to your project for a guide on how to get started. For a walkthrough on how to build a very simple media application using some libraries of the toolkit, refer to this guide . For good reference on how to use all the libraries available in the toolkit, refer to the code of the media-sample app.","title":"Getting started"},{"location":"media-ui/","text":"Media UI library \u00b6 This library contains a set of composables for media player apps: Individual controls like Play, Pause and Seek buttons; Components that might combine multiple controls, like PlayPauseButton and MediaControlButtons ; Screens, like PlayerScreen , BrowseScreen and EntityScreen . The previews of the composables can be found in the debug folder of the module source code. This library is not dependent on any specific player implementation as per architecture overview . Stateful components \u00b6 Most of the components available in this library contain an overloaded version of themselves which accept either a UI model ( MediaUiModel , PlaylistUiModel ) or PlayerUiState or PlayerViewModel as parameters. We call those versions \u201cstateful components\u201d, which is a different definition from the compose documentation . While the stateless components provide full customization, the stateful components provide convenience (if the default implementation suits your project requirements), as can be seen in the example below. Stateless PodcastControlButtons usage: PodcastControlButtons ( onPlayButtonClick = { }, onPauseButtonClick = { }, playPauseButtonEnabled = true , playing = false , percent = 0f , onSeekBackButtonClick = { }, seekBackButtonEnabled = true , onSeekForwardButtonClick = { }, seekForwardButtonEnabled = true , ) Stateful PodcastControlButtons usage: PodcastControlButtons ( playerViewModel = viewModel , playerUiState = playerUiState , ) Further examples on how to use these components can be found in the Stateful PlayerScreen guide .","title":"Media UI lib"},{"location":"media-ui/#media-ui-library","text":"This library contains a set of composables for media player apps: Individual controls like Play, Pause and Seek buttons; Components that might combine multiple controls, like PlayPauseButton and MediaControlButtons ; Screens, like PlayerScreen , BrowseScreen and EntityScreen . The previews of the composables can be found in the debug folder of the module source code. This library is not dependent on any specific player implementation as per architecture overview .","title":"Media UI library"},{"location":"media-ui/#stateful-components","text":"Most of the components available in this library contain an overloaded version of themselves which accept either a UI model ( MediaUiModel , PlaylistUiModel ) or PlayerUiState or PlayerViewModel as parameters. We call those versions \u201cstateful components\u201d, which is a different definition from the compose documentation . While the stateless components provide full customization, the stateful components provide convenience (if the default implementation suits your project requirements), as can be seen in the example below. Stateless PodcastControlButtons usage: PodcastControlButtons ( onPlayButtonClick = { }, onPauseButtonClick = { }, playPauseButtonEnabled = true , playing = false , percent = 0f , onSeekBackButtonClick = { }, seekBackButtonEnabled = true , onSeekForwardButtonClick = { }, seekForwardButtonEnabled = true , ) Stateful PodcastControlButtons usage: PodcastControlButtons ( playerViewModel = viewModel , playerUiState = playerUiState , ) Further examples on how to use these components can be found in the Stateful PlayerScreen guide .","title":"Stateful components"},{"location":"media/","text":"Media Domain library \u00b6 This library currently contains a set of models and repositories that are common to media apps. But it can be expanded in the future to also include common use cases, as per domain layer guide . The data and domain layer guides seem to imply that the definitions of the repositories should belong to the data layer. This would make the domain library dependent on a specific data library. In this project, the repositories are defined ( not implemented) in the domain layer. This makes the domain layer independent of external layers, and any implementation of the repositories can be used: the ones provided by the toolkit, or custom implementations provided by your project. The reason for having a domain library is described in the architecture overview .","title":"Media Domain lib"},{"location":"media/#media-domain-library","text":"This library currently contains a set of models and repositories that are common to media apps. But it can be expanded in the future to also include common use cases, as per domain layer guide . The data and domain layer guides seem to imply that the definitions of the repositories should belong to the data layer. This would make the domain library dependent on a specific data library. In this project, the repositories are defined ( not implemented) in the domain layer. This makes the domain layer independent of external layers, and any implementation of the repositories can be used: the ones provided by the toolkit, or custom implementations provided by your project. The reason for having a domain library is described in the architecture overview .","title":"Media Domain library"},{"location":"media3-backend/","text":"Wear Media3 Backend library \u00b6 For more information, visit the documentation: https://google.github.io/horologist/media3-backend Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-media3-backend:<version>\" }","title":"Media3 Backend lib"},{"location":"media3-backend/#wear-media3-backend-library","text":"For more information, visit the documentation: https://google.github.io/horologist/media3-backend","title":"Wear Media3 Backend library"},{"location":"media3-backend/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-media3-backend:<version>\" }","title":"Download"},{"location":"network-awareness/","text":"Network Awareness library \u00b6 Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-network-awareness:<version>\" } Problem Statement \u00b6 On Wear choice of network is critical to efficient applications. See https://developer.android.com/training/wearables/data/network-access for more information. The default behaviour is roughly Use Paired Bluetooth connection when it is available. Use Wifi when available and Charging. Use LTE if no other network is available. Wifi and Cell may be requested specifically by the application. This leads to some suboptimal decisions Downloading large downloads over the slow and shared bluetooth connection. This may overload the connection and starve other applications. Instead, Wifi or Cellular would be better used to quickly download and then close the connection. Using LTE for trivial requests when not really required. Using a single current network for all traffic regardless of length or important of the request. Functionality \u00b6 This library allows defining rules based on the RequestType and NetworkType, currently integrated into OkHttp. public interface NetworkingRules { /** * Is this request considered high bandwidth and should activate LTE or Wifi. */ public fun isHighBandwidthRequest ( requestType : RequestType ): Boolean /** * Checks whether this request is allowed on the current network type. */ public fun checkValidRequest ( requestType : RequestType , currentNetworkInfo : NetworkInfo ): RequestCheck /** * Returns the preferred network for a request. * * Null means no suitable network. */ public fun getPreferredNetwork ( networks : Networks , requestType : RequestType ): NetworkStatus? } It allow allows logging network usage and visibility into network status. See media-sample for an example. Key classes to observe usage of UampNetworkingRules - defining the app specific rules for the network. MediaInfoTimeText - An example of displaying network status and usage to the user. NetworkAwareCallFactory - Used to wrap an OkHttp Call.Factory when passed to a library such as Coil. NetworkSelectingCallFactory - Used to apply the networking rules to OkHttp. NetworkRepository - The Repository for the current network state. HighBandwidthNetworkMediator - a mediator for requesting high bandwidth networks.","title":"Guide"},{"location":"network-awareness/#network-awareness-library","text":"","title":"Network Awareness library"},{"location":"network-awareness/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-network-awareness:<version>\" }","title":"Download"},{"location":"network-awareness/#problem-statement","text":"On Wear choice of network is critical to efficient applications. See https://developer.android.com/training/wearables/data/network-access for more information. The default behaviour is roughly Use Paired Bluetooth connection when it is available. Use Wifi when available and Charging. Use LTE if no other network is available. Wifi and Cell may be requested specifically by the application. This leads to some suboptimal decisions Downloading large downloads over the slow and shared bluetooth connection. This may overload the connection and starve other applications. Instead, Wifi or Cellular would be better used to quickly download and then close the connection. Using LTE for trivial requests when not really required. Using a single current network for all traffic regardless of length or important of the request.","title":"Problem Statement"},{"location":"network-awareness/#functionality","text":"This library allows defining rules based on the RequestType and NetworkType, currently integrated into OkHttp. public interface NetworkingRules { /** * Is this request considered high bandwidth and should activate LTE or Wifi. */ public fun isHighBandwidthRequest ( requestType : RequestType ): Boolean /** * Checks whether this request is allowed on the current network type. */ public fun checkValidRequest ( requestType : RequestType , currentNetworkInfo : NetworkInfo ): RequestCheck /** * Returns the preferred network for a request. * * Null means no suitable network. */ public fun getPreferredNetwork ( networks : Networks , requestType : RequestType ): NetworkStatus? } It allow allows logging network usage and visibility into network status. See media-sample for an example. Key classes to observe usage of UampNetworkingRules - defining the app specific rules for the network. MediaInfoTimeText - An example of displaying network status and usage to the user. NetworkAwareCallFactory - Used to wrap an OkHttp Call.Factory when passed to a library such as Coil. NetworkSelectingCallFactory - Used to apply the networking rules to OkHttp. NetworkRepository - The Repository for the current network state. HighBandwidthNetworkMediator - a mediator for requesting high bandwidth networks.","title":"Functionality"},{"location":"simple-media-app-guide/","text":"Build a simple player app \u00b6 This guide will walk you through on how to build a very simple media player app for Wear OS, capable of playing a media which is hosted on the internet. This guide assumes that you are familiar with: How to create Wear OS projects in Android Studio; Kotlin programming language; Jetpack Compose; Display a PlayerScreen \u00b6 1 - Add dependency \u00b6 Add dependency on media-ui to your project\u2019s build.gradle : implementation \"com.google.android.horologist:horologist-media-ui:$horologist_version\" 2 - Add PlayerScreen \u00b6 Add the following code to your Activity \u2019s onCreate function: setContent { PlayerScreen ( mediaDisplay = { TextMediaDisplay ( title = \"Song name\" , artist = \"Artist name\" ) }, controlButtons = { PodcastControlButtons ( onPlayButtonClick = { }, onPauseButtonClick = { }, playPauseButtonEnabled = true , playing = false , percent = 0f , onSeekBackButtonClick = { }, seekBackButtonEnabled = true , onSeekForwardButtonClick = { }, seekForwardButtonEnabled = true , ) }, buttons = { } ) } This code is displaying PlayerScreen on the app. PlayerScreen is a full screen composable that contains slots parameters to pass the contents to be displayed for media display, control buttons and more. In this sample, we are using the UI components TextMediaDisplay and PodcastControlButtons , provided by the UI library, as values to parameters of PlayerScreen . Result \u00b6 Run the app and you should see the following screen: None of the controls are working, as they were not implemented yet. Make the screen functional \u00b6 1 - Add dependencies \u00b6 Add dependency on media-data , compose-layout and media3-exoplayer to your project\u2019s build.gradle: implementation \"com.google.android.horologist:horologist-media-data:$horologist_version\" implementation ( \"androidx.media3:media3-exoplayer:$media3_version\" ) 2 - Add ViewModel \u00b6 Add a ViewModel extending PlayerViewModel , providing an instance of PlayerRepositoryImpl : class MyViewModel ( player : Player , playerRepository : PlayerRepositoryImpl = PlayerRepositoryImpl () ) : PlayerViewModel ( playerRepository ) {} 3 - Add init block \u00b6 Add the following init block to the ViewModel to connect the Player to the PlayerRepository , set a media and update the position of the player every second: init { viewModelScope . launch { playerRepository . connect ( player ) {} playerRepository . setMedia ( Media ( id = \"wake_up_02\" , uri = \"https://storage.googleapis.com/uamp/The_Kyoto_Connection_-_Wake_Up/02_-_Geisha.mp3\" , title = \"Geisha\" , artist = \"The Kyoto Connection\" ) ) // update the track position while app is in foreground while ( isActive ) { delay ( 1000 ) playerRepository . updatePosition () } } } 4 - Create an instance of the ViewModel \u00b6 Change your Activity \u2019s onCreate function to: val player = ExoPlayer . Builder ( this ). build () // ViewModels should NOT be created here like this val viewModel = MyViewModel ( player ) PlayerScreen ( mediaDisplay = { playerUiState -> DefaultMediaDisplay ( media = playerUiState . media ) }, controlButtons = { playerUiState -> PodcastControlButtons ( playerViewModel = viewModel , playerUiState = playerUiState , ) }, buttons = { } ) We are creating an instance of ExoPlayer , passing it to the ViewModel . Then for the PlayerScreen slots we are using: the DefaultMediaDisplay component, which accepts a MediaUiModel instance as parameter; the stateful version of PodcastControlButtons , which accepts instances of PlayerViewModel and PlayerUiState as parameters to hook the controls with the ViewModel ; Result \u00b6 Run the app again and this time, play with the screen controls as the app should be able to play, pause, and seek the media now:","title":"Simple app guide"},{"location":"simple-media-app-guide/#build-a-simple-player-app","text":"This guide will walk you through on how to build a very simple media player app for Wear OS, capable of playing a media which is hosted on the internet. This guide assumes that you are familiar with: How to create Wear OS projects in Android Studio; Kotlin programming language; Jetpack Compose;","title":"Build a simple player app"},{"location":"simple-media-app-guide/#display-a-playerscreen","text":"","title":"Display a PlayerScreen"},{"location":"simple-media-app-guide/#1-add-dependency","text":"Add dependency on media-ui to your project\u2019s build.gradle : implementation \"com.google.android.horologist:horologist-media-ui:$horologist_version\"","title":"1 - Add dependency"},{"location":"simple-media-app-guide/#2-add-playerscreen","text":"Add the following code to your Activity \u2019s onCreate function: setContent { PlayerScreen ( mediaDisplay = { TextMediaDisplay ( title = \"Song name\" , artist = \"Artist name\" ) }, controlButtons = { PodcastControlButtons ( onPlayButtonClick = { }, onPauseButtonClick = { }, playPauseButtonEnabled = true , playing = false , percent = 0f , onSeekBackButtonClick = { }, seekBackButtonEnabled = true , onSeekForwardButtonClick = { }, seekForwardButtonEnabled = true , ) }, buttons = { } ) } This code is displaying PlayerScreen on the app. PlayerScreen is a full screen composable that contains slots parameters to pass the contents to be displayed for media display, control buttons and more. In this sample, we are using the UI components TextMediaDisplay and PodcastControlButtons , provided by the UI library, as values to parameters of PlayerScreen .","title":"2 - Add PlayerScreen"},{"location":"simple-media-app-guide/#result","text":"Run the app and you should see the following screen: None of the controls are working, as they were not implemented yet.","title":"Result"},{"location":"simple-media-app-guide/#make-the-screen-functional","text":"","title":"Make the screen functional"},{"location":"simple-media-app-guide/#1-add-dependencies","text":"Add dependency on media-data , compose-layout and media3-exoplayer to your project\u2019s build.gradle: implementation \"com.google.android.horologist:horologist-media-data:$horologist_version\" implementation ( \"androidx.media3:media3-exoplayer:$media3_version\" )","title":"1 - Add dependencies"},{"location":"simple-media-app-guide/#2-add-viewmodel","text":"Add a ViewModel extending PlayerViewModel , providing an instance of PlayerRepositoryImpl : class MyViewModel ( player : Player , playerRepository : PlayerRepositoryImpl = PlayerRepositoryImpl () ) : PlayerViewModel ( playerRepository ) {}","title":"2 - Add ViewModel"},{"location":"simple-media-app-guide/#3-add-init-block","text":"Add the following init block to the ViewModel to connect the Player to the PlayerRepository , set a media and update the position of the player every second: init { viewModelScope . launch { playerRepository . connect ( player ) {} playerRepository . setMedia ( Media ( id = \"wake_up_02\" , uri = \"https://storage.googleapis.com/uamp/The_Kyoto_Connection_-_Wake_Up/02_-_Geisha.mp3\" , title = \"Geisha\" , artist = \"The Kyoto Connection\" ) ) // update the track position while app is in foreground while ( isActive ) { delay ( 1000 ) playerRepository . updatePosition () } } }","title":"3 - Add init block"},{"location":"simple-media-app-guide/#4-create-an-instance-of-the-viewmodel","text":"Change your Activity \u2019s onCreate function to: val player = ExoPlayer . Builder ( this ). build () // ViewModels should NOT be created here like this val viewModel = MyViewModel ( player ) PlayerScreen ( mediaDisplay = { playerUiState -> DefaultMediaDisplay ( media = playerUiState . media ) }, controlButtons = { playerUiState -> PodcastControlButtons ( playerViewModel = viewModel , playerUiState = playerUiState , ) }, buttons = { } ) We are creating an instance of ExoPlayer , passing it to the ViewModel . Then for the PlayerScreen slots we are using: the DefaultMediaDisplay component, which accepts a MediaUiModel instance as parameter; the stateful version of PodcastControlButtons , which accepts instances of PlayerViewModel and PlayerUiState as parameters to hook the controls with the ViewModel ;","title":"4 - Create an instance of the ViewModel"},{"location":"simple-media-app-guide/#result_1","text":"Run the app again and this time, play with the screen controls as the app should be able to play, pause, and seek the media now:","title":"Result"},{"location":"tiles/","text":"Tiles Library \u00b6 CoroutinesTileService \u00b6 Provides a CoroutinesTileService, which also acts as a LifecycleService. class ExampleTileService : CoroutinesTileService () { override suspend fun tileRequest ( requestParams : RequestBuilders . TileRequest ): Tile { return Tile . Builder () // create your tile here . build () } override suspend fun resourcesRequest ( requestParams : RequestBuilders . ResourcesRequest ): ResourceBuilders . Resources = ResourceBuilders . Resources . Builder (). setVersion ( \"1\" ). build () } Coil Image Helpers \u00b6 Provides a suspending method to load an image from the network, convert to an RGB_565 bitmap, and encode as a Tiles InlineImageResource. val imageResource = imageLoader . loadImageResource ( applicationContext , \"https://raw.githubusercontent.com/google/horologist/main/docs/media-ui/playerscreen.png\" ) { // Show a local error image if missing error ( R . drawable . missingImage ) } Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-tiles:<version>\" }","title":"Guide"},{"location":"tiles/#tiles-library","text":"","title":"Tiles Library"},{"location":"tiles/#coroutinestileservice","text":"Provides a CoroutinesTileService, which also acts as a LifecycleService. class ExampleTileService : CoroutinesTileService () { override suspend fun tileRequest ( requestParams : RequestBuilders . TileRequest ): Tile { return Tile . Builder () // create your tile here . build () } override suspend fun resourcesRequest ( requestParams : RequestBuilders . ResourcesRequest ): ResourceBuilders . Resources = ResourceBuilders . Resources . Builder (). setVersion ( \"1\" ). build () }","title":"CoroutinesTileService"},{"location":"tiles/#coil-image-helpers","text":"Provides a suspending method to load an image from the network, convert to an RGB_565 bitmap, and encode as a Tiles InlineImageResource. val imageResource = imageLoader . loadImageResource ( applicationContext , \"https://raw.githubusercontent.com/google/horologist/main/docs/media-ui/playerscreen.png\" ) { // Show a local error image if missing error ( R . drawable . missingImage ) }","title":"Coil Image Helpers"},{"location":"tiles/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.android.horologist:horologist-tiles:<version>\" }","title":"Download"},{"location":"updating-old/","text":"Updating & releasing Horologist \u00b6 This guide is currently not in use. See updating.md instead. This doc is mostly for maintainers. New features & bugfixes \u00b6 All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch. Jetpack Compose Snapshots \u00b6 We publish snapshot versions of Horologist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch. Updating to a newer Compose snapshot \u00b6 As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review. Releasing \u00b6 Once the next Jetpack Compose version is out, we're ready to push a new release: #1: Merge snapshot into main \u00b6 First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot #2: Update dependencies \u00b6 Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes. #3: Bump the version number \u00b6 Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name. #4: Push to GitHub \u00b6 Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central. #5: Create release \u00b6 Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website . #6: Prepare the next development version \u00b6 The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"Updating & releasing Horologist"},{"location":"updating-old/#updating-releasing-horologist","text":"This guide is currently not in use. See updating.md instead. This doc is mostly for maintainers.","title":"Updating &amp; releasing Horologist"},{"location":"updating-old/#new-features-bugfixes","text":"All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch.","title":"New features &amp; bugfixes"},{"location":"updating-old/#jetpack-compose-snapshots","text":"We publish snapshot versions of Horologist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch.","title":"Jetpack Compose Snapshots"},{"location":"updating-old/#updating-to-a-newer-compose-snapshot","text":"As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review.","title":"Updating to a newer Compose snapshot"},{"location":"updating-old/#releasing","text":"Once the next Jetpack Compose version is out, we're ready to push a new release:","title":"Releasing"},{"location":"updating-old/#1-merge-snapshot-into-main","text":"First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot","title":"#1: Merge snapshot into main"},{"location":"updating-old/#2-update-dependencies","text":"Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes.","title":"#2: Update dependencies"},{"location":"updating-old/#3-bump-the-version-number","text":"Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name.","title":"#3: Bump the version number"},{"location":"updating-old/#4-push-to-github","text":"Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central.","title":"#4: Push to GitHub"},{"location":"updating-old/#5-create-release","text":"Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website .","title":"#5: Create release"},{"location":"updating-old/#6-prepare-the-next-development-version","text":"The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"#6: Prepare the next development version"},{"location":"updating/","text":"Updating & releasing Horologist \u00b6 This doc is mostly for maintainers. Ensure your Sonatype JIRA credentials are set in your environment variables. export ORG_GRADLE_PROJECT_mavenCentralUsername = username export ORG_GRADLE_PROJECT_mavenCentralPassword = password Decrypt the signing key to release a public build. release/signing-setup.sh '<Horologist AES key>' gradlew clean publish --no-parallel --stacktrace release/signing-cleanup.sh The deployment then needs to be manually released via the Nexus Repository Manager . See Releasing Deployment from OSSRH . Snapshot release \u00b6 For a snapshot release, the signing key is not used. Ensure VERSION_NAME in gradle.properties has the -SNAPSHOT suffix or specify the version via -PVERSION_NAME=... . gradlew -PVERSION_NAME = 0 .0.1-SNAPSHOT clean publish --no-parallel --stacktrace","title":"Update guide"},{"location":"updating/#updating-releasing-horologist","text":"This doc is mostly for maintainers. Ensure your Sonatype JIRA credentials are set in your environment variables. export ORG_GRADLE_PROJECT_mavenCentralUsername = username export ORG_GRADLE_PROJECT_mavenCentralPassword = password Decrypt the signing key to release a public build. release/signing-setup.sh '<Horologist AES key>' gradlew clean publish --no-parallel --stacktrace release/signing-cleanup.sh The deployment then needs to be manually released via the Nexus Repository Manager . See Releasing Deployment from OSSRH .","title":"Updating &amp; releasing Horologist"},{"location":"updating/#snapshot-release","text":"For a snapshot release, the signing key is not used. Ensure VERSION_NAME in gradle.properties has the -SNAPSHOT suffix or specify the version via -PVERSION_NAME=... . gradlew -PVERSION_NAME = 0 .0.1-SNAPSHOT clean publish --no-parallel --stacktrace","title":"Snapshot release"},{"location":"using-snapshot-version/","text":"Using a Snapshot Version of the Library \u00b6 If you would like to depend on the cutting edge version of the Horologist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.android.horologist:horologist-tiles:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below). Using Jetpack Compose Snapshots \u00b6 If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable Horologist release forcing an older version of those libraries. We publish snapshot versions of Horologist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.android.horologist:horologist-tiles:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Snapshots"},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","text":"If you would like to depend on the cutting edge version of the Horologist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.android.horologist:horologist-tiles:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below).","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-jetpack-compose-snapshots","text":"If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable Horologist release forcing an older version of those libraries. We publish snapshot versions of Horologist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.android.horologist:horologist-tiles:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using Jetpack Compose Snapshots"}]}