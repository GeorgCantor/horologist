{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Horologist is a group of libraries that aim to supplement Wear OS developers with features that are commonly required by developers but not yet available.</p>"},{"location":"#media","title":"\ud83c\udfb5 Media","text":"<p>Horologist provides the Media Toolkit: a set of libraries to build Media apps on Wear OS and a sample app that you can run to see the toolkit in action.</p> <p>The toolkit includes:</p> <ul> <li>horologist-media-ui: common media UI components and screens like <code>PlayerScreen</code>.</li> <li>horologist-media: domain model for Media related functionality. Provides an abstraction to the UI module (<code>horologist-media-ui</code>) that is agnostic to the Player implementation.</li> <li>horologist-media-data: implementation of the domain module (<code>horologist-media</code>) using Media3.</li> <li>horologist-media3-backend: Player on top of Media3 including functionalities such as avoiding playing music on the watch speaker.</li> <li>horologist-media-sample: sample app to listen to downloaded music.</li> </ul> Player Screen Browse Screen Entity Screen"},{"location":"#composables","title":"\ud83d\udcc5 Composables","text":"<p>High quality prebuilt composables, such as Time and Date pickers.</p> <ul> <li>horologist-composables</li> </ul> DatePicker TimePickerWith12HourClock TimePicker SegmentedProgressIndicator SquareSegmentedProgressIndicator"},{"location":"#compose-layout","title":"\ud83d\udcd0 Compose Layout","text":"<p>Layout related functionality such as a Navigation Aware Scaffold.</p> <ul> <li>horologist-compose-layout</li> </ul> fillMaxRectangle()"},{"location":"#audio-and-ui","title":"\ud83d\udd0a Audio and UI","text":"<p>Domain model for Audio related functionality. Volume Control, Output switching. Subscribing to a Flow of changes in audio or output.</p> <ul> <li>horologist-audio</li> <li>horologist-audio-ui</li> </ul> VolumeScreen"},{"location":"#tiles","title":"\u2630 Tiles","text":"<p>Kotlin coroutines flavoured TileService.</p> <p>horologist-tiles</p>"},{"location":"#why-the-name","title":"Why the name?","text":"<p>The name mirrors the Accompanist name, and is also Watch related.</p> <p>https://en.wiktionary.org/wiki/horologist</p> <p>horologist (Noun)    Someone who makes or repairs timepieces, watches or clocks.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Please contribute! We will gladly review any pull requests submitted. Make sure to read the Contributing page to know what our expectations of contributions are.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2023 The Android Open Source Project\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"audio-ui/","title":"Audio Settings UI library","text":""},{"location":"audio-ui/#volume-screen","title":"Volume Screen","text":"<p>A volume screen, showing the current audio output (headphones, speakers) and allowing to change the button with a stepper or bezel.</p> <pre><code>VolumeScreen(focusRequester = focusRequester)\n</code></pre> <p></p>"},{"location":"audio-ui/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-audio-ui:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"audio/","title":"Audio Settings Library","text":"<p>Domain model for Volume and Audio Output.</p> <pre><code>val audioRepository = SystemAudioRepository.fromContext(application)\n\naudioRepository.increaseVolume()\n\nval volumeState: StateFlow&lt;VolumeState&gt; = audioRepository.volumeState\n\nval audioOutput: StateFlow&lt;AudioOutput&gt; = audioRepository.audioOutput\n\nval output = audioOutput.value\nif (output is AudioOutput.BluetoothHeadset) {\nprintln(output.name)\n}\n</code></pre>"},{"location":"audio/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-audio:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"auth-composables/","title":"Auth Composables","text":"<p>This library contains a set of composables screens and components related to authentication.</p> <p>The previews of the composables can be found in the <code>debug</code> folder of the module source code.</p> <p>This library is not dependent on any specific authentication implementation as per architecture overview.</p>"},{"location":"auth-composables/#screens","title":"Screens","text":"<ul> <li> <p>SignInPlaceholderScreen</p> </li> <li> <p>SelectAccountScreen</p> </li> <li> <p>CheckYourPhoneScreen</p> </li> </ul>"},{"location":"auth-composables/#dialogs","title":"Dialogs","text":"<ul> <li>SignedInConfirmationDialog</li> </ul>"},{"location":"auth-composables/#chips","title":"Chips","text":"<ul> <li> <p>CreateAccountChip</p> </li> <li> <p>GuestModeChip</p> </li> <li> <p>OtherOptionsChip</p> </li> <li> <p>SignInChip</p> </li> </ul>"},{"location":"auth-data-phone/","title":"Auth Data Phone","text":"<p>This library contains implementation for Mobile apps for some of the authentication methods provided by the <code>auth-data</code> library.</p>"},{"location":"auth-data-phone/#token-sharing","title":"Token sharing","text":"<ul> <li>TokenBundleRepository<ul> <li>TokenBundleRepositoryImpl</li> </ul> </li> </ul>"},{"location":"auth-data/","title":"Auth Data","text":"<p>This library contains implementation for Wear apps for most of the authentication methods listed in the Authentication on wearables guide.</p> <p>The repositories of this library are built mainly to support the components from auth-ui library, but can be used with your own UI components.</p>"},{"location":"auth-data/#token-sharing","title":"Token sharing","text":"<ul> <li>TokenBundleRepository<ul> <li>TokenBundleRepositoryImpl</li> </ul> </li> </ul>"},{"location":"auth-data/#google-sign-in","title":"Google Sign-In","text":"<ul> <li>GoogleSignInAuthUserRepository</li> </ul>"},{"location":"auth-data/#oauth-pkce","title":"OAuth (PKCE)","text":"<ul> <li>PKCEConfigRepository<ul> <li>PKCEConfigRepositoryGoogleImpl</li> </ul> </li> <li>PKCEOAuthCodeRepository<ul> <li>PKCEOAuthCodeRepositoryImpl</li> </ul> </li> <li>PKCETokenRepository<ul> <li>PKCETokenRepositoryGoogleImpl</li> </ul> </li> </ul>"},{"location":"auth-data/#oauth-device-grant","title":"OAuth (Device Grant)","text":"<ul> <li>DeviceGrantConfigRepository<ul> <li>DeviceGrantConfigRepositoryDefaultImpl</li> </ul> </li> <li>DeviceGrantTokenRepository<ul> <li>DeviceGrantTokenRepositoryGoogleImpl</li> </ul> </li> <li>DeviceGrantVerificationInfoRepository<ul> <li>DeviceGrantVerificationInfoRepositoryGoogleImpl</li> </ul> </li> </ul>"},{"location":"auth-googlesignin-guide/","title":"Google Sign-In guide","text":"<p>This guide will walk you through on how to display a screen on your watch app so that users can select their Google account to sign-in to your app.</p>"},{"location":"auth-googlesignin-guide/#requirements","title":"Requirements","text":"<p>Follow the setup instructions for integrating Google Sign-in into an Android app from this link.</p>"},{"location":"auth-googlesignin-guide/#getting-started","title":"Getting started","text":"<ol> <li> <p>Add dependencies</p> <p>Add the following dependencies to your project\u2019s build.gradle:</p> <pre><code>dependencies {\nimplementation \"com.google.android.horologist:horologist-auth-composables:&lt;version&gt;\"\nimplementation \"com.google.android.horologist:horologist-auth-ui:&lt;version&gt;\"\nimplementation \"com.google.android.horologist:horologist-base-ui:&lt;version&gt;\"\n}\n</code></pre> </li> <li> <p>Create an instance of <code>GoogleSignInClient</code></p> <p>Create an instance of GoogleSignInClient, according to your requirements, for example:</p> <pre><code>val googleSignInClient = GoogleSignIn.getClient(\napplicationContext,\nGoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)\n.requestEmail()\n.build()\n)\n</code></pre> </li> </ol>"},{"location":"auth-googlesignin-guide/#display-the-screen","title":"Display the screen","text":"<ol> <li> <p>Create a ViewModel</p> <p>Create your implementation  of GoogleSignInViewModel,  passing the <code>GoogleSignInClient</code> created:</p> <pre><code>class MyGoogleSignInViewModel(\ngoogleSignInClient: GoogleSignInClient,\n) : GoogleSignInViewModel(googleSignInClient)\n</code></pre> </li> <li> <p>Display the screen</p> <p>Display  the GoogleSignInScreen  passing an instance of the <code>GoogleSignInViewModel</code> created:</p> <pre><code>GoogleSignInScreen(\n   onAuthCancelled = { /* code to navigate to another screen on this event */ },\n   onAuthSucceed = { /* code to navigate to another screen on this event */ },\n   viewModel = hiltViewModel&lt;MyGoogleSignInViewModel&gt;()\n)\n</code></pre> </li> </ol> <p>This sample uses Hilt to retrieve an instance of the ViewModel, but you should use what suits your project best, see this link for more info.</p>"},{"location":"auth-googlesignin-guide/#retrieve-the-signed-in-account","title":"Retrieve the signed in account","text":"<p>In order to have access an instance of the GoogleSignInAccount selected by the user, follow the steps:</p> <ol> <li> <p>Implement <code>GoogleSignInEventListener</code></p> <pre><code>class GoogleSignInEventListenerImpl : GoogleSignInEventListener {\noverride suspend fun onSignedIn(account: GoogleSignInAccount) {\n// your implementation using the account parameter\n}\n}\n</code></pre> </li> <li> <p>Pass the listener to the ViewModel</p> <p>Pass an instance of <code>GoogleSignInEventListener</code> to <code>GoogleSignInViewModel</code>:</p> <pre><code>class MyGoogleSignInViewModel(\ngoogleSignInClient: GoogleSignInClient,\ngoogleSignInEventListener: GoogleSignInEventListener,\n) : GoogleSignInViewModel(googleSignInClient, googleSignInEventListener)\n</code></pre> </li> </ol>"},{"location":"auth-overview/","title":"Auth libraries","text":""},{"location":"auth-overview/#overview","title":"Overview","text":"<p>The purpose of the auth libraries is to:</p> <ul> <li>help developers to build apps following   the Sign-In guidelines for Wear OS;</li> <li>provide implementation (for Wear and Mobile) for most of the authentication methods listed in   the Authentication on wearables   guide;</li> </ul> <p>The following libraries are provided:</p> <ul> <li>auth-composables: composable screens for Authentication use cases, with no   dependency on the <code>auth-data</code> library.</li> <li>auth-ui: composable screens for Authentication use cases, with integration with   the <code>auth-data</code> library.</li> <li>auth-data: implementation for Wear apps for most of the authentication methods   listed in   the Authentication on wearables   guide.</li> <li>auth-data-phone: implementation for Mobile apps for some of the   authentication methods provided by the <code>auth-data</code> library.</li> </ul> <p>The following sample apps are also provided:</p> <ul> <li>auth-sample-wear: sample wear app to authenticate using   different methods.</li> <li>auth-sample-phone: sample mobile app to authenticate using   different methods.</li> </ul>"},{"location":"auth-overview/#architecture-overview","title":"Architecture overview","text":"<p>The auth libraries are separated by layers (UI and data), following the recommended app architecture. The reason for including an extra UI library (<code>auth-composables</code>) is to provide flexibility to projects that would like to only use the UI components that are not dependent on <code>auth-data</code>.</p>"},{"location":"auth-overview/#getting-started","title":"Getting started","text":"<p>The usage of the auth libraries will vary according to the requirements of your project.</p> <p>As per architecture overview, your project might not need to add all the auth libraries as dependency. If that\u2019s the case, refer to the documentation of each library required to your project for a guide on how to get started.</p>"},{"location":"auth-sample-apps/","title":"Auth sample apps","text":""},{"location":"auth-sample-apps/#wear-sample","title":"Wear sample","text":"<p>The app showcases the implementation of the following authentication methods:</p> <ul> <li>Token sharing</li> <li>OAuth (PKCE)</li> <li>OAuth (Device Grant)</li> <li>Google Sign-In</li> </ul>"},{"location":"auth-sample-apps/#phone-sample","title":"Phone sample","text":"<p>The app showcases the implementation of the following authentication methods:</p> <ul> <li>Token sharing</li> </ul>"},{"location":"auth-tokenshare-guide/","title":"Token sharing guide","text":"<p>This guide will walk you through on how to securely transfer authentication data from the phone app to the watch app using Horologist's Auth libraries.</p>"},{"location":"auth-tokenshare-guide/#requirements","title":"Requirements","text":"<p>Horologist Auth library is built on top of Wearable Data Layer API, so your phone and watch apps must:</p> <ul> <li>have APK signatures and the signature schemes identical;</li> <li>the same package name;</li> </ul>"},{"location":"auth-tokenshare-guide/#getting-started","title":"Getting started","text":"<ol> <li> <p>Add dependencies</p> <p>Add the following dependencies to your project\u2019s build.gradle.</p> <p>For the phone app project:</p> <pre><code>dependencies {\nimplementation \"com.google.android.horologist:horologist-auth-data-phone:&lt;version&gt;\"\nimplementation \"com.google.android.horologist:horologist-datalayer:&lt;version&gt;\"\n}\n</code></pre> <p>For the watch app project:</p> <pre><code>dependencies {\nimplementation \"com.google.android.horologist:horologist-auth-data:&lt;version&gt;\"\nimplementation \"com.google.android.horologist:horologist-datalayer:&lt;version&gt;\"\n}\n</code></pre> </li> <li> <p>Add capability to phone app project</p> <p>On the phone app project, add a <code>wear.xml</code> file in the <code>res/values</code> folder with the following content:</p> <pre><code>&lt;resources&gt;\n&lt;string-array name=\"android_wear_capabilities\"&gt;\n&lt;item&gt;horologist_phone&lt;/item&gt;\n&lt;/string-array&gt;\n&lt;/resources&gt;\n</code></pre> </li> <li> <p>Create a <code>WearDataLayerRegistry</code></p> <p>In both projects, create an instance of WearDataLayerRegistry from the datalayer:</p> <pre><code>val registry = WearDataLayerRegistry.fromContext(\napplication = // application context,\ncoroutineScope = // a coroutine scope\n)\n</code></pre> <p>This class should be created as a singleton in your app.</p> </li> <li> <p>Define the data to be transferred</p> <p>Define which authentication data that should be transferred from the phone to the watch. It can be a data class with many properties, it can also be a protocol buffer. For this guide, we will pass a simple <code>String</code> instance.</p> </li> <li> <p>Create a <code>Serializer</code> for the data</p> <p>Create a DataStore <code>Serializer</code> class for the class defined to be transferred from the phone to the watch (<code>String</code> for this guide):</p> <pre><code>public object TokenSerializer : Serializer&lt;String&gt; {\noverride val defaultValue: String = \"\"\n\noverride suspend fun readFrom(input: InputStream): String =\nInputStreamReader(input).readText()\n\noverride suspend fun writeTo(t: String, output: OutputStream) {\nwithContext(Dispatchers.IO) {\noutput.write(t.toByteArray())\n}\n}\n}   </code></pre> <p>This class should preferable be placed in a shared module between the phone and watch projects, but could also be duplicated in both projects.</p> <p>More information about this serialization in this blog post.</p> </li> </ol>"},{"location":"auth-tokenshare-guide/#send-authentication-data-from-the-phone","title":"Send authentication data from the phone","text":"<ol> <li> <p>Create a <code>TokenBundleRepository</code> on the phone project</p> <p>Create an instance of TokenBundleRepository on the phone app project:</p> <pre><code>val tokenBundleRepository = TokenBundleRepositoryImpl(\nregistry = registry,\ncoroutineScope = // a coroutine scope,\nserializer = TokenSerializer\n)   </code></pre> </li> <li> <p>Check if the repository is available (optional)</p> <p>Before using the repository, you can check if it is available to be used on the current device with:</p> <pre><code>tokenBundleRepository.isAvailable()\n</code></pre> <p>If the repository is not available on the device, all the calls to it will fail silently.</p> <p>See the requirements of Wearable Data Layer API.</p> </li> <li> <p>Send authentication data</p> <p>The authentication data can be sent from the phone calling <code>update</code>:</p> <pre><code>tokenBundleRepository.update(\"token\")\n</code></pre> </li> </ol>"},{"location":"auth-tokenshare-guide/#receive-authentication-data-on-the-watch","title":"Receive authentication data on the watch","text":"<ol> <li> <p>Create a <code>TokenBundleRepository</code> on the watch project</p> <p>Create an instance of TokenBundleRepository on the watch app project:</p> <pre><code>val tokenBundleRepository = TokenBundleRepositoryImpl.create(\nregistry = registry,\nserializer = TokenSerializer\n)\n</code></pre> </li> <li> <p>Receive authentication data</p> <p>The authentication data can be listened from the watch via the <code>flow</code> property: <pre><code>tokenBundleRepository.flow\n</code></pre></p> </li> </ol>"},{"location":"auth-ui/","title":"Auth UI","text":"<p>This library contains a set of composables screens and components related to authentication.</p> <p>The previews of the composables can be found in the <code>debug</code> folder of the module source code.</p> <p>The composables of this module might depend on repository interfaces defined in auth-data library. The implementation of these repositories does not necessary need to be from <code>auth-data</code>, they can be your own implementation. Some of the composables might depend on an external library.</p>"},{"location":"auth-ui/#screens","title":"Screens","text":""},{"location":"auth-ui/#common","title":"Common","text":""},{"location":"auth-ui/#signinpromptscreen","title":"SignInPromptScreen","text":"<p>A screen to prompt users to sign in.</p> <p>It helps achieve to the following best practices:</p> <ul> <li>Explain sign-in benefits</li> <li>Provide alternatives</li> </ul>"},{"location":"auth-ui/#google-sign-in","title":"Google Sign-In","text":""},{"location":"auth-ui/#googlesigninscreen","title":"GoogleSignInScreen","text":"<p>A screen for the Google Sign-In authentication method.</p> <p>It uses different screens from auth-composables to display the full authentication flow.</p> <p>It relies on the Google Sign-In for Android library for authentication and account selection. So an instance of GoogleSignInClient has to be provided to <code>GoogleSignInViewModel</code>.</p>"},{"location":"auth-ui/#oauth","title":"OAuth","text":""},{"location":"auth-ui/#pkcesigninscreen","title":"PKCESignInScreen","text":"<p>A screen for the OAuth (PKCE) authentication method.</p> <p>It uses different screens from auth-composables to display the full authentication flow.</p> <p>A implementation for the following repositories are required to be provided:</p> <ul> <li>PKCEConfigRepository</li> <li>PKCEOAuthCodeRepository</li> <li>PKCETokenRepository</li> </ul>"},{"location":"auth-ui/#devicegrantsigninscreen","title":"DeviceGrantSignInScreen","text":"<p>A screen for the OAuth (Device Grant) authentication method.</p> <p>It uses different screens from auth-composables to display the full authentication flow.</p> <p>A implementation for the following repositories are required to be provided:</p> <ul> <li>DeviceGrantConfigRepository</li> <li>DeviceGrantVerificationInfoRepository</li> <li>DeviceGrantTokenRepository</li> </ul>"},{"location":"composables/","title":"Composables library","text":""},{"location":"composables/#date-picker","title":"Date Picker","text":""},{"location":"composables/#segmented-progress-indicator","title":"Segmented Progress Indicator","text":""},{"location":"composables/#time-pickers","title":"Time Pickers","text":""},{"location":"composables/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-composables:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"compose-layout/","title":"Compose Layout library","text":""},{"location":"compose-layout/#navigation-scaffold","title":"Navigation Scaffold.","text":"<p>Syncs the TimeText, PositionIndicator and Scaffold to the current navigation destination state. The TimeText will scroll out of the way of content automatically.</p> <pre><code>WearNavScaffold(\nstartDestination = \"home\",\nnavController = navController\n) {\nscalingLazyColumnComposable(\n\"home\",\nscrollStateBuilder = { ScalingLazyListState(initialCenterItemIndex = 0) }\n) {\nMenuScreen(\nscrollState = it.scrollableState,\nfocusRequester = it.viewModel.focusRequester\n)\n}\n\nscalingLazyColumnComposable(\n\"items\",\nscrollStateBuilder = { ScalingLazyListState() }\n) {\nScalingLazyColumn(\nmodifier = Modifier\n.fillMaxSize()\n.scrollableColumn(it.viewModel.focusRequester, it.scrollableState),\nstate = it.scrollableState\n) {\nitems(100) {\nText(\"i = $it\")\n}\n}\n}\n\nscrollStateComposable(\n\"settings\",\nscrollStateBuilder = { ScrollState(0) }\n) {\nColumn(\nmodifier = Modifier\n.fillMaxSize()\n.verticalScroll(state = it.scrollableState)\n.scrollableColumn(focusRequester = it.viewModel.focusRequester, scrollableState = it.scrollableState),\nhorizontalAlignment = Alignment.CenterHorizontally\n) {\n(1..100).forEach {\nText(\"i = $it\")\n}\n}\n}\n}\n</code></pre>"},{"location":"compose-layout/#box-inset-layout","title":"Box Inset Layout.","text":"<p>Use as a break glass for simple layout to fit within a safe square.</p> <pre><code>Box(\nmodifier = Modifier\n.fillMaxRectangle()\n) {\n// App Content here        \n}\n</code></pre> <p></p>"},{"location":"compose-layout/#fade-away-modifier","title":"Fade Away Modifier","text":""},{"location":"compose-layout/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-compose-layout:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"compose-tools/","title":"Compose Tools library","text":""},{"location":"compose-tools/#tile-previews","title":"Tile Previews.","text":"<p>Android Studio Preview support for tiles, using the TilesRenderer inside and AndroidView. Uses either raw Tiles proto, or the TilesLayoutRenderer abstraction to define a predictable process for generating a Tile for a given state.</p> <pre><code>@WearPreviewDevices\n@WearPreviewFontSizes\n@Composable\nfun SampleTilePreview() {\nval context = LocalContext.current\n\nval tileState = remember { SampleTileRenderer.TileState(0) }\n\nval resourceState = remember {\nval image =\nBitmapFactory.decodeResource(context.resources, R.drawable.ic_uamp).toImageResource()\nSampleTileRenderer.ResourceState(image)\n}\n\nval renderer = remember {\nSampleTileRenderer(context)\n}\n\nTileLayoutPreview(\ntileState,\nresourceState,\nrenderer\n)\n}\n</code></pre> <p></p>"},{"location":"compose-tools/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-compose-tools:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"contributing/","title":"How to Contribute","text":"<p>We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.</p> <p>If you find a common problem that you think would help other Wear developers please consider submitting a PR. Please avoid significant work before raising an issue https://github.com/google/horologist/issues with the label \"Feature Request\"</p>"},{"location":"contributing/#development","title":"Development","text":"<p>The project should work immediately from a fresh checkout in Android Studio (Stable or newer) or Gradle (./gradlew).</p> <p>When submitting a PR, please check API compatibility and lint rules first.</p> <p>A good first step is</p> <pre><code>$ ./gradlew spotlessApply spotlessCheck compileDebugSources compileReleaseSources metalavaGenerateSignature metalavaGenerateSignatureDebug lintDebug\n</code></pre> <p>Also make sure you have Git LFS installed.</p> <p>If you change any code affecting screenshot tests, then run the following and check the failures in the <code>out</code> directory.</p> <pre><code>$ ./gradlew verifyPaparazziDebug\n</code></pre> <p>To record the new golden images, run the following and check in the specific files that failed. Paparazzi has some tolerance for minor changes, so not all diffs need be committed.</p> <pre><code>$ ./gradlew recordPaparazziDebug\n</code></pre>"},{"location":"contributing/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one.</p> <p>You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.</p>"},{"location":"contributing/#code-reviews","title":"Code reviews","text":"<p>All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.</p>"},{"location":"contributing/#translation-and-localization","title":"Translation and localization","text":"<p>This project uses a semi-automatic pipeline to translate strings. When new or updated localized strings are ready, a PR is generated (example: google/horologist#692). Only the files configured via localization.bzl are sent for translation.</p> <p>If you see a problem with translated text, don't edit localized resource files (e.g. <code>res/values-en/strings.xml</code>) manually, as they'll be overwritten. Instead, file an issue and use the l10n label. This will then be forwarded to the relevant teams.</p>"},{"location":"contributing/#project-direction-and-ownership","title":"Project Direction and Ownership","text":"<p>There are a couple of reasons we may not accept an otherwise valuable contribution.</p> <ul> <li>Where the internal framework feature team, thinks the contribution is against the long term direction of the library.</li> <li>Where long term ownership is unclear, such as a large contribution that likely involves ongoing maintenance.</li> </ul>"},{"location":"datalayer-helpers-guide/","title":"DataLayer helpers libraries","text":"<p>These libraries provides an easy means to detect and install your app across both watch and phone.</p> <p>However, they are not intended to cover complex use cases, or complex interactions between watch and phone.</p>"},{"location":"datalayer-helpers-guide/#getting-started","title":"Getting started","text":"<ol> <li> <p>Include the necessary dependency:</p> <pre><code>dependencies {\n    implementation \"com.google.android.horologist:horologist-datalayer-watch:&lt;version&gt;\"\n}\n</code></pre> <p>and</p> <pre><code>dependencies {\n    implementation \"com.google.android.horologist:horologist-datalayer-phone:&lt;version&gt;\"\n}\n</code></pre> <p>For your watch and phone projects respectively.</p> </li> <li> <p>Initialize the client, including passing a <code>WearDataLayerRegistry</code>.</p> <pre><code>val appHelper = WearDataLayerAppHelper(context, wearDataLayerRegistry, scope)\n\n// or\nval appHelper = PhoneDataLayerAppHelper(context, wearDataLayerRegistry)\n</code></pre> </li> </ol>"},{"location":"datalayer-helpers-guide/#typical-use-cases","title":"Typical use cases:","text":"<ol> <li> <p>Connection and installation status</p> <p>This is something that your app may do from time to time, or on start up.</p> <pre><code>val connectedNodes = appHelper.connectedNodes()\n</code></pre> <p>The resulting list might will contain entries such as:</p> <pre><code>AppHelperNodeStatus(\n    id=7cd1c38a,\n    displayName=Google Pixel Watch,\n    isAppInstalled=true,\n    nodeType=WATCH,\n    surfacesInfo=# SurfacesInfo@125fcbff\n        complications {\n            instance_id: 1234\n            name: \"MyComplication\"\n            timestamp {\n                nanos: 738000000\n                seconds: 1680015523\n            }\n            type: \"SHORT_TEXT\"\n        }\n        tiles {\n            name: \"MyTile\"\n            timestamp {\n                nanos: 364000000\n                seconds: 1680016845\n            }\n        }\n)\n</code></pre> </li> <li> <p>Responding to availability change</p> <p>Once you've established the app on both devices, you may wish to respond to when the partner device connects or disconnects. For example, you may only want to show a \"launch workout\" button on the phone when the watch is connected.</p> <pre><code>val nodes by appHelper.connectedAndInstalledNodes\n.collectAsStateWithLifecycle()\n</code></pre> </li> <li> <p>Installing the app on the other device</p> <p>Where the app isn't installed on the other device - be that phone or watch - then the library offers a one step option to launch installation:</p> <pre><code>appHelper.installOnNode(node.id)\n</code></pre> </li> <li> <p>Launching the app on the other device</p> <p>If the app is installed on the other device, you can launch it remotely:</p> <pre><code>val result = appHelper.startRemoteOwnApp(node.id)\n</code></pre> </li> <li> <p>Launching a specific activity on the other device</p> <p>In addition to launching your own app, you may wish to launch a different activity as part of the user journey:</p> <pre><code>val config = activityConfig { packageName = \"com.example.myapp\"\nclassFullName = \"com.example.myapp.MyActivity\"\n}\nappHelper.startRemoteActivity(node.id, config)\n</code></pre> </li> <li> <p>Launching the companion app</p> <p>In some cases, it can be useful to launch the companion app, either from the watch or the phone.</p> <p>For example, if the connected device does not have your Tile installed, you may wish to offer the user the option to navigate to the companion app to install it:</p> <pre><code>if (node.installedTiles.isEmpty() &amp;&amp; askUserAttempts &lt; MAX_ATTEMPTS) {\n// Show guidance to the user and then launch companion\n// to allow the to install the Tile.\nval result = appHelper.startCompanion(nodeStatus.id)\n}\n</code></pre> </li> <li> <p>Tracking Tile installation (Wear-only)</p> <p>To determine whether your Tile(s) are installed, add the following to your <code>TileService</code>:</p> <p>In <code>onTileAddEvent</code>:</p> <pre><code>wearAppHelper.markTileAsInstalled(\"SummaryTile\")\n</code></pre> <p>In <code>onTileRemoveEvent</code>:</p> <pre><code>wearAppHelper.markTileAsRemoved(\"SummaryTile\")\n</code></pre> </li> <li> <p>Tracking Complication installation (Wear-only)</p> <p>To determine whether your Complication(s) are in-use, add the following to your <code>ComplicationDataSourceService</code>:</p> <p>In <code>onComplicationActivated</code>:</p> <pre><code>wearAppHelper.markComplicationAsActivated(\"GoalsComplication\")\n</code></pre> <p>In <code>onComplicationDeactivated</code>:</p> <pre><code>wearAppHelper.markComplicationAsDeactivated(\"GoalsComplication\")\n</code></pre> </li> </ol>"},{"location":"datalayer/","title":"DataLayer library","text":"<p>For more information, visit the documentation: https://google.github.io/horologist/datalayer</p> <p>DataStore documentation https://developer.android.com/topic/libraries/architecture/datastore</p> <p>Direct DataLayer sample code https://github.com/android/wear-os-samples</p> <p>TODO</p> <ul> <li>Use CapabilityClient instead of NodeClient</li> <li>Consider switching local/remote to owner/reader</li> <li>Support WearableListenerService to handle changes to data.</li> </ul>"},{"location":"datalayer/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-datalayer:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"media-data/","title":"Media Data library","text":"<p>This library contains the implementation of the repositories defined in the media domain library, using Media3 and an internal database as data sources.</p> <p>It also exposes its data sources classes so they can be used by your custom repositories.</p>"},{"location":"media-data/#mediadownloadservice","title":"MediaDownloadService","text":"<p>An implementation of Media3\u2019s <code>DownloadService</code> that, in conjunction with auxiliary classes, will monitor the state and progress of media downloads, and update the information in the internal database.</p>"},{"location":"media-data/#usage","title":"Usage","text":"<ol> <li> <p>Add your own implementation of the service, extending <code>MediaDownloadService</code>;</p> </li> <li> <p>Add your service implementation to your app\u2019s <code>AndroidManifest.xml</code>: <pre><code>&lt;service android:name=\"MediaDownloadServiceImpl\"\nandroid:exported=\"false\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"com.google.android.exoplayer.downloadService.action.RESTART\"/&gt;\n&lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;\n&lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre></p> </li> </ol>"},{"location":"media-playerscreen/","title":"Stateful PlayerScreen guide","text":"<p>This is a guide on how to use the stateful <code>PlayerScreen</code> with your own implementation of <code>PlayerRepository</code>.</p>"},{"location":"media-playerscreen/#basic-usage","title":"Basic usage","text":""},{"location":"media-playerscreen/#1-implement-playerrepository","title":"1. Implement PlayerRepository","text":"<pre><code>class PlayerRepositoryImpl : PlayerRepository {\n// implement required properties and functions\n}\n</code></pre> <p>In the sample implementation below, the repository listens to the events of Media3's  <code>Player</code> and update its property values accordingly (see <code>onIsPlayingChanged</code>). Its operations are  also called on the <code>Player</code> (see <code>setPlaybackSpeed</code>).</p> <pre><code>class PlayerRepositoryImpl(\nprivate val player: Player\n) : PlayerRepository {\n\nprivate val _currentState: MutableStateFlow&lt;PlayerState&gt; = MutableStateFlow(PlayerState.Idle)\noverride val currentState: StateFlow&lt;PlayerState&gt; = _currentState\n\nprivate val listener = object : Player.Listener {\n\noverride fun onIsPlayingChanged(isPlaying: Boolean) {\n_currentState.value = if (isPlaying) { PlayerState.Playing\n} else {\nPlayerState.Ready\n}\n}\n}\n\ninit {\nplayer.add(listener)\n}\n\nfun setPlaybackSpeed(speed: Float) { player.setPlaybackSpeed(speed) }\n}\n</code></pre>"},{"location":"media-playerscreen/#2-extend-playerviewmodel","title":"2. Extend PlayerViewModel","text":"<p>Pass your implementation of <code>PlayerRepository</code> as constructor parameter.</p> <pre><code>class MyCustomViewModel(\nplayerRepository: PlayerRepositoryImpl\n): PlayerViewModel(playerRepository) {\n// add custom implementation\n}\n</code></pre>"},{"location":"media-playerscreen/#3-add-playerscreen","title":"3. Add PlayerScreen","text":"<p>Pass your <code>PlayerViewModel</code> extension as value to the constructor parameter.</p> <pre><code>PlayerScreen(playerViewModel = myCustomViewModel)\n</code></pre>"},{"location":"media-playerscreen/#class-diagram","title":"Class diagram","text":"<p>The following diagram shows the interactions between the classes.</p> <p></p>"},{"location":"media-sample/","title":"Media sample app","text":"<p>The goal of this sample is to show how to implement an audio media app for Wear OS, using the Horologist media libraries, following the design principles described in Considerations for media apps .</p> <p>The app supports listening to downloaded music. It loads a music catalog from a remote server and allows the user to browse the albums and songs. Tapping on a song will play it through connected speakers or headphones. Under the hood it uses Media3.</p>"},{"location":"media-sample/#features","title":"Features","text":"<p>The app showcases the implementation of the following features:</p> <ul> <li>Media playback, restricted to paired Bluetooth devices</li> <li>Launch of Bluetooth settings to connect devices for media playback</li> <li>Volume control</li> <li>Radial background based on media artwork color palette</li> <li>Download media</li> <li>API sync with WorkManager</li> <li>Network rules</li> <li>Splash screen</li> <li>Marquee text for song titles</li> <li>Tiles</li> </ul> <p>This list is not exhaustive.</p>"},{"location":"media-sample/#audio","title":"Audio","text":"<p>Music provided by the Free Music Archive.</p> <ul> <li>Wake Up by   The Kyoto Connection.</li> </ul> <p>Recordings provided by the Ambisonic Sound Library.</p> <ul> <li>Pre Game Marching Band by Watson Wu</li> <li>Chickens on a Farm by Watson Wu</li> <li>Rural Market Busker by Stephan Schutze</li> <li>Steamtrain Interior by Stephan Schutze</li> <li>Rural Road Car Pass by Stephan Schutze</li> <li>10 Feet from Shore by Watson Wu</li> </ul>"},{"location":"media-toolkit/","title":"Media Toolkit","text":""},{"location":"media-toolkit/#overview","title":"Overview","text":"<p>Horologist provides what it is called the \"Media Toolkit\": a set of libraries to build media apps on Wear OS and a sample app that you can run to see the toolkit in action.</p> <p>The following modules in the Horologist project are part of the toolkit:</p> <ul> <li>media-ui: common media UI components and screens like <code>PlayerScreen</code>.</li> <li>media: domain model for media related functionality. Provides an abstraction to the UI   module (<code>media-ui</code>) that is agnostic to the <code>Player</code> implementation.</li> <li>media-data: implementation of the domain module (<code>media</code>) using Media3.</li> <li>media3-backend: <code>Player</code> on top of Media3 including functionalities such as   avoiding playing music on the watch speaker.</li> <li>media-sample: sample app to listen to downloaded music.</li> </ul>"},{"location":"media-toolkit/#architecture-overview","title":"Architecture overview","text":"<p>The Media Toolkit libraries are separated by layers (UI, domain and data) following the recommended app architecture .</p> <p>The reason for including a domain layer is to provide flexibility to projects to use the UI library or the data library independently.</p> <p>For example, if your project already contains an implementation for the player and you are only interested in using the media screens provided by the toolkit, then only the UI library needs to be added as a dependency. Thus, no extra dependencies ( e.g. Media3) will be added to your project.</p> <p>On the other hand, if your project does not need any of the media screens or media UI components provided by the UI library, and you are only interested in the player implementation, then only the data library needs to be added as a dependency to your project.</p>"},{"location":"media-toolkit/#getting-started","title":"Getting started","text":"<p>The usage of the toolkit will vary according to the requirements of your project.</p> <p>As per architecture overview, your project might not need to add all the libraries of the toolkit as dependency. If that\u2019s the case, refer to the documentation of each library required to your project for a guide on how to get started.</p> <p>For a walkthrough on how to build a very simple media application using some libraries of the toolkit, refer to this guide.</p> <p>For good reference on how to use all the libraries available in the toolkit, refer to the code of the media-sample app.</p>"},{"location":"media-ui/","title":"Media UI library","text":"<p>This library contains a set of composables for media player apps:</p> <p>Individual controls like Play, Pause and Seek buttons; Components that might combine multiple controls, like <code>PlayPauseButton</code> and <code>MediaControlButtons</code>; Screens, like <code>PlayerScreen</code>, <code>BrowseScreen</code> and <code>EntityScreen</code>.</p> <p>The previews of the composables can be found in the <code>debug</code> folder of the module source code.</p> <p>This library is not dependent on any specific player implementation as per architecture overview.</p>"},{"location":"media-ui/#stateful-components","title":"Stateful components","text":"<p>Most of the components available in this library contain an overloaded version of themselves which accept either a UI model (<code>MediaUiModel</code>, <code>PlaylistUiModel</code>) or <code>PlayerUiState</code> or <code>PlayerViewModel</code> as parameters. We call those versions \u201cstateful components\u201d, which is a different definition from the compose documentation .</p> <p>While the stateless components provide full customization, the stateful components provide convenience (if the default implementation suits your project requirements), as can be seen in the example below.</p> <p>Stateless <code>PodcastControlButtons</code> usage:</p> <pre><code>PodcastControlButtons(\nonPlayButtonClick = { },\nonPauseButtonClick = { },\nplayPauseButtonEnabled = true,\nplaying = false,\npercent = 0f,\nonSeekBackButtonClick = { },\nseekBackButtonEnabled = true,\nonSeekForwardButtonClick = { },\nseekForwardButtonEnabled = true,\n)\n</code></pre> <p>Stateful <code>PodcastControlButtons</code> usage:</p> <pre><code>PodcastControlButtons(\nplayerViewModel = viewModel,\nplayerUiState = playerUiState,\n)\n</code></pre> <p>Further examples on how to use these components can be found in the Stateful PlayerScreen guide.</p>"},{"location":"media/","title":"Media Domain library","text":"<p>This library currently contains a set of models and repositories that are common to media apps. But it can be expanded in the future to also include common use cases, as per domain layer guide.</p> <p>The data and domain layer guides seem to imply that the definitions of the repositories should belong to the data layer. This would make the domain library dependent on a specific data library. In this project, the repositories are defined ( not implemented) in the domain layer. This makes the domain layer independent of external layers, and any implementation of the repositories can be used: the ones provided by the toolkit, or custom implementations provided by your project.</p> <p>The reason for having a domain library is described in the architecture overview.</p>"},{"location":"media3-backend/","title":"Wear Media3 Backend library","text":""},{"location":"media3-backend/#features","title":"Features","text":"<p>The media3-backend module implements many of the suggested approaches at https://developer.android.com/training/wearables/overlays/audio. These enforce the best practices that will make you app work well for users on a range of Wear OS devices.</p> <p>These build on top of the Media3 player featuring ExoPlayer which is optimised for Wear Playback, and is the standard playback engine for Wear OS media apps.</p> <p>All functionality is demonstrated in the <code>media-sample</code> app, and as such is not described here with extensive code samples.</p>"},{"location":"media3-backend/#bluetooth-headphone-connections","title":"Bluetooth Headphone Connections","text":"<p>Any extended playback such as music, podcasts, or radio should only use a connected bluetooth speaker. See https://developer.android.com/training/wearables/principles#bluetooh-headphones for principles applying to Media and Wear OS apps generally.</p> <p>When not connected, the default Watch Speaker will be used and so this must be actively  avoided.</p> <p>Horologist provides the <code>PlaybackRules</code> abstraction that allows you to intercept playback requests through your UI, a system media Tile, pressing a bluetooth headphone, or other services such as  assistant.</p> <pre><code>public object Normal : PlaybackRules {\n/**\n     * Can the given item be played with it's given state.\n     */\noverride suspend fun canPlayItem(mediaItem: MediaItem): Boolean = true\n\n/**\n     * Can Media be played with the given audio target.\n     */\noverride fun canPlayWithOutput(audioOutput: AudioOutput): Boolean =\naudioOutput is AudioOutput.BluetoothHeadset\n}\n</code></pre> <p>The <code>WearConfiguredPlayer</code> wraps the ExoPlayer to avoid starting playback and also pause immediately if the headset becomes disconnected. It will prompt the user to connect a headset at this point.</p> <p>The <code>AudioOutputSelector</code> and default implementation <code>BluetoothSettingsOutputSelector</code> are used to prompt the user to connect a Bluetooth headset and then continue playback once connected.</p> <pre><code>public interface AudioOutputSelector {\n/**\n     * Change from the current audio output, according to some sensible logic,\n     * and return when either the user has selected a new audio output or returning null\n     * if timed out.\n     */\npublic suspend fun selectNewOutput(currentAudioOutput: AudioOutput): AudioOutput?\n}\n</code></pre>"},{"location":"media3-backend/#audio-offload","title":"Audio Offload","text":"<p>In line with https://exoplayer.dev/battery-consumption.html#audio-playback, Audio Offload allows your app to playback audio while in the background without waking up. This dramatically improves the users battery life, as well as decreasing the occurrences of Audio Underruns.</p> <p>The <code>AudioOffloadManager</code> configures and controls Audio Offload, enabling sleeping while your app is in the background and disabling while in the foreground.</p>"},{"location":"media3-backend/#logging","title":"Logging","text":"<p>The <code>media3-backend</code> module interacts with <code>ExoPlayer</code> instance, but many events may be required for error handling, logging or metrics.  Your can register your own <code>Player.Listener</code> with the <code>ExoPlayer</code> instance, but to receive generally useful events you can implement <code>ErrorReporter</code> to receive events and report with Android <code>Log</code> or write to a database.</p> <p>Other things in the Horologist media libs will report events, and they all consistently use <code>ErrorReporter</code> to allow you to understand all activity in your app.</p> <pre><code>public interface ErrorReporter {\npublic fun logMessage(\nmessage: String,\ncategory: Category = Category.Unknown,\nlevel: Level = Level.Info\n)\n}\n</code></pre>"},{"location":"media3-backend/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-media3-backend:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"network-awareness/","title":"Network Awareness library","text":""},{"location":"network-awareness/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-network-awareness:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"network-awareness/#problem-statement","title":"Problem Statement","text":"<p>On Wear choice of network is critical to efficient applications. See https://developer.android.com/training/wearables/data/network-access for more information.</p> <p>The default behaviour is roughly</p> <ul> <li>Use Paired Bluetooth connection when it is available.</li> <li>Use Wifi when available and Charging.</li> <li>Use LTE if no other network is available.</li> <li>Wifi and Cell may be requested specifically by the application.</li> </ul> <p>This leads to some suboptimal decisions</p> <ul> <li>Downloading large downloads over the slow and shared bluetooth connection.  This may overload the   connection and starve other applications. Instead, Wifi or Cellular would be better used to    quickly download and then close the connection.</li> <li>Using LTE for trivial requests when not really required.</li> <li>Using a single current network for all traffic regardless of length or important of the request.</li> </ul>"},{"location":"network-awareness/#functionality","title":"Functionality","text":"<p>This library allows defining rules based on the RequestType and NetworkType, currently integrated into OkHttp.</p> <pre><code>public interface NetworkingRules {\n/**\n     * Is this request considered high bandwidth and should activate LTE or Wifi.\n     */\npublic fun isHighBandwidthRequest(requestType: RequestType): Boolean\n\n/**\n     * Checks whether this request is allowed on the current network type.\n     */\npublic fun checkValidRequest(\nrequestType: RequestType,\ncurrentNetworkInfo: NetworkInfo\n): RequestCheck\n\n/**\n     * Returns the preferred network for a request.\n     *\n     * Null means no suitable network.\n     */\npublic fun getPreferredNetwork(\nnetworks: Networks,\nrequestType: RequestType\n): NetworkStatus?\n}\n</code></pre> <p>It allow allows logging network usage and visibility into network status.</p> <p>See media-sample for an example. Key classes to observe usage of</p> <ul> <li>UampNetworkingRules - defining the app specific rules for the network.</li> <li>MediaInfoTimeText - An example of displaying network status and usage to the user.</li> <li>NetworkAwareCallFactory - Used to wrap an OkHttp Call.Factory when passed to a library such as Coil.</li> <li>NetworkSelectingCallFactory - Used to apply the networking rules to OkHttp.</li> <li>NetworkRepository - The Repository for the current network state.</li> <li>HighBandwidthNetworkMediator - a mediator for requesting high bandwidth networks.</li> </ul>"},{"location":"simple-media-app-guide/","title":"Build a simple media player app","text":"<p>This guide will walk you through on how to build a very simple media player app for Wear OS, capable of playing a media which is hosted on the internet.</p> <p>This guide assumes that you are familiar with:</p> <ul> <li>How to create Wear OS projects in Android Studio;</li> <li>Kotlin programming language;</li> <li>Jetpack Compose;</li> </ul>"},{"location":"simple-media-app-guide/#display-a-playerscreen","title":"Display a PlayerScreen","text":""},{"location":"simple-media-app-guide/#1-add-dependency","title":"1 - Add dependency","text":"<p>Create a new project from Android Studio by choosing a Wear OS Empty Compose Activity. Add dependency on <code>media-ui</code> to your project\u2019s <code>build.gradle</code>:</p> <pre><code>implementation \"com.google.android.horologist:horologist-media-ui:$horologist_version\"\n</code></pre>"},{"location":"simple-media-app-guide/#2-add-playerscreen","title":"2 - Add <code>PlayerScreen</code>","text":"<p>Add the following code to your <code>Activity</code>\u2019s <code>onCreate</code> function:</p> <pre><code>setContent {\nPlayerScreen(\nmediaDisplay = {\nTextMediaDisplay(\ntitle = \"Song name\",\nsubtitle = \"Artist name\"\n)\n},\ncontrolButtons = {\nPodcastControlButtons(\nonPlayButtonClick = { },\nonPauseButtonClick = { },\nplayPauseButtonEnabled = true,\nplaying = false,\npercent = 0f,\nonSeekBackButtonClick = { },\nseekBackButtonEnabled = true,\nonSeekForwardButtonClick = { },\nseekForwardButtonEnabled = true,\n)\n},\nbuttons = { }\n)\n}\n</code></pre> <p>This code is displaying <code>PlayerScreen</code> on the app. <code>PlayerScreen</code> is a full screen composable that contains slots parameters to pass the contents to be displayed for media display, control buttons and more.</p> <p>In this sample, we are using the UI components <code>TextMediaDisplay</code> and <code>PodcastControlButtons</code>, provided by the UI library, as values to parameters of <code>PlayerScreen</code>.</p>"},{"location":"simple-media-app-guide/#result","title":"Result","text":"<p>Run the app and you should see the following screen:</p> <p></p> <p>None of the controls are working, as they were not implemented yet.</p>"},{"location":"simple-media-app-guide/#make-the-screen-functional","title":"Make the screen functional","text":""},{"location":"simple-media-app-guide/#1-add-dependencies","title":"1 - Add dependencies","text":"<p>Add the following dependencies to your project\u2019s build.gradle:</p> <pre><code>implementation \"com.google.android.horologist:horologist-media-data:$horologist_version\"\nimplementation \"com.google.android.horologist:horologist-audio-ui:$horologist_version\"\nimplementation(\"androidx.media3:media3-exoplayer:$media3_version\")\n</code></pre>"},{"location":"simple-media-app-guide/#2-add-viewmodel","title":"2 - Add <code>ViewModel</code>","text":"<p>Add a <code>ViewModel</code> extending <code>PlayerViewModel</code>, providing an instance of <code>PlayerRepositoryImpl</code>:</p> <pre><code>class MyViewModel(\nplayer: Player,\nplayerRepository: PlayerRepositoryImpl = PlayerRepositoryImpl()\n) : PlayerViewModel(playerRepository) {}\n</code></pre>"},{"location":"simple-media-app-guide/#3-add-init-block","title":"3 - Add init block","text":"<p>Add the following init block to the <code>ViewModel</code> to connect the <code>Player</code> to the <code>PlayerRepository</code>, set a media and update the position of the player every second:</p> <pre><code>init {\nviewModelScope.launch {\nplayerRepository.connect(player) {}\n\nplayerRepository.setMedia(\nMedia(\nid = \"wake_up_02\",\nuri = \"https://storage.googleapis.com/uamp/The_Kyoto_Connection_-_Wake_Up/02_-_Geisha.mp3\",\ntitle = \"Geisha\",\nartist = \"The Kyoto Connection\"\n)\n)\n}\n}\n</code></pre>"},{"location":"simple-media-app-guide/#4-create-an-instance-of-the-viewmodel","title":"4 - Create an instance of the <code>ViewModel</code>","text":"<p>Change your <code>Activity</code>\u2019s <code>onCreate</code> function to:</p> <pre><code>val player = ExoPlayer.Builder(this)\n.setSeekForwardIncrementMs(5000L)\n.setSeekBackIncrementMs(5000L)\n.build()\n// ViewModels should NOT be created here like this\nval viewModel = MyViewModel(player)\nval volumeViewModel = createVolumeViewModel()\n\nPlayerScreen(\nplayerViewModel = viewModel,\nvolumeViewModel = volumeViewModel,\nmediaDisplay = { playerUiState: PlayerUiState -&gt;\nDefaultMediaInfoDisplay(playerUiState)\n},\ncontrolButtons = { playerUIController: PlayerUiController,\nplayerUiState: PlayerUiState -&gt;\nPodcastControlButtons(\nplayerController = playerUIController,\nplayerUiState = playerUiState\n)\n},\nbuttons = { }\n)\n</code></pre> <p>Add <code>createVolumeViewModel</code> function to create a VolumeViewModel:</p> <pre><code>fun createVolumeViewModel(): VolumeViewModel {\nval audioRepository = SystemAudioRepository.fromContext(application)\nval vibrator: Vibrator = application.getSystemService(Vibrator::class.java)\nreturn VolumeViewModel(audioRepository, audioRepository, onCleared = {\naudioRepository.close()\n}, vibrator)\n}\n</code></pre> <p>We are creating an instance of <code>ExoPlayer</code>, passing it to the <code>ViewModel</code>.</p> <p>Then for the <code>PlayerScreen</code> slots we are using:</p> <ul> <li>the <code>DefaultMediaDisplay</code> component, which accepts a <code>MediaUiModel</code> instance as parameter;</li> <li>the stateful version of <code>PodcastControlButtons</code>, which accepts   instances of <code>PlayerViewModel</code> and <code>PlayerUiState</code>as parameters to hook the controls with   the <code>ViewModel</code>;</li> </ul>"},{"location":"simple-media-app-guide/#result_1","title":"Result","text":"<p>Run the app again and this time, play with the screen controls as the app should be able to play, pause, and seek the media now:</p> <p></p>"},{"location":"tiles/","title":"Tiles Library","text":""},{"location":"tiles/#suspendingtileservice","title":"SuspendingTileService","text":"<p>Provides a SuspendingTileService, which also acts as a LifecycleService.</p> <pre><code>class ExampleTileService : SuspendingTileService() {\noverride suspend fun tileRequest(requestParams: RequestBuilders.TileRequest): Tile {\nreturn Tile.Builder()\n// create your tile here\n.build()\n}\n\noverride suspend fun resourcesRequest(\nrequestParams: RequestBuilders.ResourcesRequest\n): ResourceBuilders.Resources = ResourceBuilders.Resources.Builder().setVersion(\"1\").build()\n}\n</code></pre>"},{"location":"tiles/#coil-image-helpers","title":"Coil Image Helpers","text":"<p>Provides a suspending method to load an image from the network, convert to an RGB_565 bitmap, and encode as a Tiles InlineImageResource.</p> <pre><code>val imageResource = imageLoader.loadImageResource(applicationContext, \"https://raw.githubusercontent.com/google/horologist/main/docs/media-ui/playerscreen.png\") {\n// Show a local error image if missing\nerror(R.drawable.missingImage)\n}\n</code></pre>"},{"location":"tiles/#download","title":"Download","text":"<pre><code>repositories {\nmavenCentral()\n}\n\ndependencies {\nimplementation \"com.google.android.horologist:horologist-tiles:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"updating-old/","title":"Updating &amp; releasing Horologist","text":"<p>This guide is currently not in use. See updating.md instead.</p> <p>This doc is mostly for maintainers.</p>"},{"location":"updating-old/#new-features-bugfixes","title":"New features &amp; bugfixes","text":"<p>All new features should be uploaded as PRs against the <code>main</code> branch.</p> <p>Once merged into <code>main</code>, they will be automatically merged into the <code>snapshot</code> branch.</p>"},{"location":"updating-old/#jetpack-compose-snapshots","title":"Jetpack Compose Snapshots","text":"<p>We publish snapshot versions of Horologist, which depend on a <code>SNAPSHOT</code> versions of Jetpack Compose. These are built from the <code>snapshot</code> branch.</p>"},{"location":"updating-old/#updating-to-a-newer-compose-snapshot","title":"Updating to a newer Compose snapshot","text":"<p>As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the <code>snapshot</code> branch:</p> <pre><code>git checkout snapshot &amp;&amp; git pull\n# Create branch for PR\ngit checkout -b update_snapshot\n</code></pre> <p>Now edit the project to depend on the new Compose SNAPSHOT version:</p> <p>Edit <code>/gradle/libs.versions.toml</code>:</p> <p>Under <code>[versions]</code>:</p> <ol> <li>Update the <code>composesnapshot</code> property to be the snapshot number</li> <li>Ensure that the <code>compose</code> property is correct</li> </ol> <p>Make sure the project builds and test pass: <pre><code>./gradlew check\n</code></pre></p> <p>Now <code>git commit</code> the changes and push to GitHub.</p> <p>Finally create a PR (with the base branch as <code>snapshot</code>) and send for review.</p>"},{"location":"updating-old/#releasing","title":"Releasing","text":"<p>Once the next Jetpack Compose version is out, we're ready to push a new release:</p>"},{"location":"updating-old/#1-merge-snapshot-into-main","title":"#1: Merge <code>snapshot</code> into <code>main</code>","text":"<p>First we merge the <code>snapshot</code> branch into <code>main</code>:</p> <pre><code>git checkout snapshot &amp;&amp; git pull\ngit checkout main &amp;&amp; git pull\n\n# Create branch for PR\ngit checkout -b main_snapshot_merge\n\n# Merge in the snapshot branch\ngit merge snapshot\n</code></pre>"},{"location":"updating-old/#2-update-dependencies","title":"#2: Update dependencies","text":"<p>Edit <code>/gradle/libs.versions.toml</code>:</p> <p>Under <code>[versions]</code>:</p> <ol> <li>Update the <code>composesnapshot</code> property to a single character (usually <code>-</code>). This disables the snapshot repository.</li> <li>Update the <code>compose</code> property to match the new release (i.e. <code>1.0.0-beta06</code>)</li> </ol> <p>Make sure the project builds and test pass: <pre><code>./gradlew check\n</code></pre></p> <p>Commit the changes.</p>"},{"location":"updating-old/#3-bump-the-version-number","title":"#3: Bump the version number","text":"<p>Edit gradle.properties:</p> <ul> <li>Update the <code>VERSION_NAME</code> property and remove the <code>-SNAPSHOT</code> suffix.</li> </ul> <p>Commit the changes, using the commit message containing the new version name.</p>"},{"location":"updating-old/#4-push-to-github","title":"#4: Push to GitHub","text":"<p>Push the branch to GitHub and create a PR against the <code>main</code> branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central.</p>"},{"location":"updating-old/#5-create-release","title":"#5: Create release","text":"<p>Once the above PR has been approved and merged, we need to create the GitHub release:</p> <ul> <li>Open up the Releases page.</li> <li>At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'.</li> <li>Make sure that the version number matches what we released (the tool guesses but is not always correct).</li> <li>Double check everything, then press 'Publish release'.</li> </ul> <p>At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website.</p>"},{"location":"updating-old/#6-prepare-the-next-development-version","title":"#6: Prepare the next development version","text":"<p>The current release is now finished, but we need to update the version for the next development version:</p> <p>Edit gradle.properties:</p> <ul> <li>Update the <code>VERSION_NAME</code> property, by increasing the version number, and adding the <code>-SNAPSHOT</code> suffix.</li> <li>Example: released version: <code>0.3.0</code>. Update to <code>0.3.1-SNAPSHOT</code></li> </ul> <p><code>git commit</code> and push to <code>main</code>.</p> <p>Finally, merge all of these changes back to <code>snapshot</code>:</p> <pre><code>git checkout snapshot &amp;&amp; git pull\ngit merge main\ngit push\n</code></pre>"},{"location":"updating/","title":"Updating &amp; releasing Horologist","text":"<p>This doc is mostly for maintainers.</p> <p>Ensure your Sonatype JIRA credentials are set in your environment variables.</p> <pre><code>export ORG_GRADLE_PROJECT_mavenCentralUsername=username\nexport ORG_GRADLE_PROJECT_mavenCentralPassword=password\n</code></pre> <p>Decrypt the signing key to release a public build.</p> <pre><code>release/signing-setup.sh '&lt;Horologist AES key&gt;'\ngradlew clean publish --no-parallel --stacktrace\nrelease/signing-cleanup.sh\n</code></pre> <p>The deployment then needs to be manually released via the Nexus Repository Manager. See Releasing Deployment from OSSRH.</p>"},{"location":"updating/#snapshot-release","title":"Snapshot release","text":"<p>For a snapshot release, the signing key is not used. Ensure <code>VERSION_NAME</code> in gradle.properties has the <code>-SNAPSHOT</code> suffix or specify the version via <code>-PVERSION_NAME=...</code>.</p> <pre><code>gradlew -PVERSION_NAME=0.0.1-SNAPSHOT clean publish --no-parallel --stacktrace\n</code></pre>"},{"location":"using-snapshot-version/","title":"Using a Snapshot Version of the Library","text":"<p>If you would like to depend on the cutting edge version of the Horologist library, you can use the snapshot versions that are published to Sonatype OSSRH's snapshot repository. These are updated on every commit to <code>main</code>.</p> <p>To do so:</p> <pre><code>repositories {\n// ...\nmaven { url 'https://oss.sonatype.org/content/repositories/snapshots' }\n}\n\ndependencies {\n// Check the latest SNAPSHOT version from the link above\nclasspath 'com.google.android.horologist:horologist-tiles:XXX-SNAPSHOT'\n}\n</code></pre> <p>You might see a number of different versioned snapshots. If we use an example:</p> <ul> <li><code>0.3.0-SNAPSHOT</code> is a build from the <code>main</code> branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03).</li> <li><code>0.3.0.compose-6574163-SNAPSHOT</code> is a build from the <code>snapshot</code> branch. This depends on the SNAPSHOT build of Jetpack Compose from build <code>6574163</code>. You should only use these if you are using Jetpack Compose snapshot versions (see below).</li> </ul>"},{"location":"using-snapshot-version/#using-jetpack-compose-snapshots","title":"Using Jetpack Compose Snapshots","text":"<p>If you're using <code>SNAPSHOT</code> versions of the <code>androidx.compose</code> libraries, you might run into issues with the current stable Horologist release forcing an older version of those libraries.</p> <p>We publish snapshot versions of Horologist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme <code>x.x.x.compose-YYYY-SNAPSHOT</code> (for example: <code>0.3.0.compose-6574163-SNAPSHOT</code>). The <code>YYYY</code> in the scheme is the snapshot build being used from AndroidX (from the example: build <code>6574163</code>). You can then use it like so:</p> <pre><code>repositories {\n// ...\nmaven { url 'https://oss.sonatype.org/content/repositories/snapshots' }\n}\n\ndependencies {\n// Check the latest SNAPSHOT version from the link above\nclasspath 'com.google.android.horologist:horologist-tiles:XXXX.compose-YYYYY-SNAPSHOT'\n}\n</code></pre> <p>These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number.</p> <p>Note: you might also see versions in the scheme <code>x.x.x.ui-YYYY-SNAPSHOT</code>. These are the same, just using an older suffix.</p>"}]}